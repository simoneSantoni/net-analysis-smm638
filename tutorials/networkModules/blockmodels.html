<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.37">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Simone Santoni">
<meta name="dcterms.date" content="2024-11-27">

<title>Inferring the Modular Structure of Networks with Weighted Stochastic Blockmodeling</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="blockmodels_files/libs/clipboard/clipboard.min.js"></script>
<script src="blockmodels_files/libs/quarto-html/quarto.js"></script>
<script src="blockmodels_files/libs/quarto-html/popper.min.js"></script>
<script src="blockmodels_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="blockmodels_files/libs/quarto-html/anchor.min.js"></script>
<link href="blockmodels_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="blockmodels_files/libs/quarto-html/quarto-syntax-highlighting-29e2c20b02301cfff04dc8050bf30c7e.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="blockmodels_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="blockmodels_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="blockmodels_files/libs/bootstrap/bootstrap-45eab9f33756b4204ced05762ced8738.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of Contents</h2>
   
  <ul class="collapse">
  <li><a href="#overview-inferring-the-modular-structure-of-networks" id="toc-overview-inferring-the-modular-structure-of-networks" class="nav-link active" data-scroll-target="#overview-inferring-the-modular-structure-of-networks"><span class="header-section-number">1</span> Overview: inferring the modular structure of networks</a></li>
  <li><a href="#notebook-setup" id="toc-notebook-setup" class="nav-link" data-scroll-target="#notebook-setup"><span class="header-section-number">2</span> Notebook setup</a></li>
  <li><a href="#toy-dataset-food-web-network" id="toc-toy-dataset-food-web-network" class="nav-link" data-scroll-target="#toy-dataset-food-web-network"><span class="header-section-number">3</span> Toy Dataset: ‘Food Web’ network</a></li>
  <li><a href="#weighted-stochastic-blockmodeling-wsbm" id="toc-weighted-stochastic-blockmodeling-wsbm" class="nav-link" data-scroll-target="#weighted-stochastic-blockmodeling-wsbm"><span class="header-section-number">4</span> Weighted Stochastic Blockmodeling (WSBM)</a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="blockmodels.ipynb" download="blockmodels.ipynb"><i class="bi bi-journal-code"></i>Jupyter</a></li><li><a href="blockmodels.docx"><i class="bi bi-file-word"></i>MS Word</a></li><li><a href="../../blockmodels.pdf"><i class="bi bi-file-pdf"></i>Typst</a></li></ul></div></nav>
</div>
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Inferring the Modular Structure of Networks with Weighted Stochastic Blockmodeling</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Simone Santoni </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 27, 2024</p>
    </div>
  </div>
  
    
  </div>
  
<div>
  <div class="abstract">
    <div class="block-title">Synopsis</div>
    This notebook shows how to infer the modular structure of weighted networks using the Weighted Stochastic Blockmodeling (WSBM) approach. WSBM extends the concept of the Stochastic Blockmodel (SBM) to incorporate edge weights into the modeling process, allowing for a more detailed representation of the network’s structure. We will use a synthetic network dataset to illustrate the key steps involved in inferring the modular structure of a weighted network using the WSBM approach.
  </div>
</div>


</header>


<section id="overview-inferring-the-modular-structure-of-networks" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Overview: inferring the modular structure of networks</h1>
<p>The notebook <a href="https://github.com/simoneSantoni/net-analysis-smm638/blob/master/tutorials/networkModules/community_detection.qmd"><code>community_detection.qmd</code></a> shows how to infer the modular structure of weighted networks using Louvain’s community-detection algorithm. The current notebook focuses on a different approach to the same problem: the weighted stochastic blockmodeling (WSBM).</p>
<p>WSBM<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> approach is an extension of the stochastic blockmodel (SBM) that incorporates edge weights into the modeling process.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> SBMs are probabilistic models used to detect community structures in networks by partitioning nodes into blocks or communities, where the probability of an edge existing between any two nodes depends only on the blocks to which the nodes belong.</p>
<p>WSBM extends this concept by considering not just the presence or absence of edges, but also the weights of the edges, which can represent the strength or capacity of connections between nodes. This allows for a more nuanced understanding of the network’s structure, capturing variations in connection strengths within and between communities.</p>
<p>The WSBM approach involves defining a likelihood function that accounts for the observed edge weights and optimizing this function to find the most likely partition of nodes into communities. This is typically done using techniques such as the Expectation-Maximization (EM) algorithm or variational inference.</p>
<p>By incorporating edge weights, WSBM provides a more detailed and accurate representation of the network, making it particularly useful for analyzing weighted networks such as social networks with varying interaction strengths, biological networks with different interaction intensities, and transportation networks with different capacities. This approach enhances the ability to uncover meaningful community structures and understand the underlying processes governing the network.</p>
<p>In this notebook, we will learn how to implement the WSBM approach using the <code>graph-tool</code> library in Python. We will use a synthetic network dataset to illustrate the key steps involved in inferring the modular structure of a weighted network using the WSBM.</p>
</section>
<section id="notebook-setup" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Notebook setup</h1>
<p>We will use the <code>graph-tool</code> library for network analysis and visualization. If you haven’t already installed <code>graph-tool</code>, you can do so using the following command:</p>
<pre class="{bash}"><code>conda activate %YOUR_ENVIRONMENT%
conda install -c conda-forge graph-tool</code></pre>
<p>Then, we can import the necessary libraries and set up the notebook environment:</p>
<div id="20a9235d" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> Image</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> graph_tool.<span class="bu">all</span> <span class="im">import</span> <span class="op">*</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="toy-dataset-food-web-network" class="level1 page-columns page-full" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Toy Dataset: ‘Food Web’ network</h1>
<p>To illustrate the WSBM approach, we will use a synthetic network dataset representing a food web. The food web network consists of different species (nodes) connected by interactions (edges) representing predator-prey relationships. The edge weights in the network represent the strength of these interactions, with higher weights indicating stronger relationships.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> It is worth noticing that the edge values are positive <span class="math inline">\([0, \infty]\)</span>.</p>
<div id="cell-fig-foodweb" class="cell page-columns page-full" data-fig-width="300" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3" data-cap-location="margin"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> collection.ns[<span class="st">"foodweb_baywet"</span>]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>graph_draw(g, pos<span class="op">=</span>g.vp._pos, output_size<span class="op">=</span>(<span class="dv">300</span>, <span class="dv">300</span>), output<span class="op">=</span><span class="st">"foodweb.png"</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>Image(filename<span class="op">=</span><span class="st">"foodweb.png"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display page-columns page-full" data-execution_count="2">
<div id="fig-foodweb" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-cap-location="margin">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-foodweb-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="blockmodels_files/figure-html/fig-foodweb-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-foodweb-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Food Web Network
</figcaption>
</figure>
</div>
</div>
</div>
<p><a href="#fig-foodweb" class="quarto-xref">Figure&nbsp;1</a> does not show a clear pattern. Let us see if we can uncover the underlying modular structure of this network using the WSBM approach.</p>
</section>
<section id="weighted-stochastic-blockmodeling-wsbm" class="level1 page-columns page-full" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Weighted Stochastic Blockmodeling (WSBM)</h1>
<p>The WSBM approach involves defining a likelihood function that accounts for the observed edge weights and optimizing this function to find the most likely partition of nodes into communities. As the following code cell shows, we can use the <code>graph-tool</code> library to implement the WSBM approach for inferring the modular structure of the food web network. Specifically, we will use the <code>minimize_nested_blockmodel_dl</code> function to fit the WSBM model to the network data. This function takes the following arguments in our example:</p>
<ul>
<li><code>g</code>: the input graph object representing the food web network</li>
<li><code>state_args</code>: a dictionary containing the edge weights (<code>recs</code>) and their types (<code>rec_types</code>) for the model fitting process</li>
<li><code>rec_types</code>: the type of edge weights, in this case, real-exponential – remember that the edge values are positive!!</li>
</ul>
<div id="cell-fig-foodweb-wsbm" class="cell page-columns page-full" data-fig-width="300" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4" data-cap-location="margin"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># model fit</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>state <span class="op">=</span> minimize_nested_blockmodel_dl(</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    g, state_args<span class="op">=</span><span class="bu">dict</span>(recs<span class="op">=</span>[g.ep.weight], rec_types<span class="op">=</span>[<span class="st">"real-exponential"</span>])</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co"># improve solution with merge-split</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">100</span>):</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    ret <span class="op">=</span> state.multiflip_mcmc_sweep(niter<span class="op">=</span><span class="dv">10</span>, beta<span class="op">=</span>np.inf)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>state.draw(</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    edge_color<span class="op">=</span>prop_to_size(g.ep.weight, power<span class="op">=</span><span class="dv">1</span>, log<span class="op">=</span><span class="va">True</span>),</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    ecmap<span class="op">=</span>(matplotlib.cm.inferno, <span class="fl">0.6</span>),</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    eorder<span class="op">=</span>g.ep.weight,</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    edge_pen_width<span class="op">=</span>prop_to_size(g.ep.weight, <span class="dv">1</span>, <span class="dv">4</span>, power<span class="op">=</span><span class="dv">1</span>, log<span class="op">=</span><span class="va">True</span>),</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    edge_gradient<span class="op">=</span>[],</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    output_size<span class="op">=</span>(<span class="dv">300</span>, <span class="dv">300</span>),</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    output<span class="op">=</span><span class="st">"foodweb-wsbm.png"</span>,</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="co"># show the plot</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>Image(filename<span class="op">=</span><span class="st">"foodweb-wsbm.png"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display page-columns page-full" data-execution_count="3">
<div id="fig-foodweb-wsbm" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-cap-location="margin">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-foodweb-wsbm-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="blockmodels_files/figure-html/fig-foodweb-wsbm-output-1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-foodweb-wsbm-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Modular Structure of the Food Web Network Inferred Using WSBM
</figcaption>
</figure>
</div>
</div>
</div>
<p><a href="#fig-foodweb-wsbm" class="quarto-xref">Figure&nbsp;2</a> shows the modular structure of the food web network inferred using the WSBM approach. Quite evidently, this is a complex visualization:</p>
<ul>
<li>The nodes are colored according to the community they belong to, with nodes of the same color representing the same community (that is, species dependent on the same resources)</li>
<li>The size of nodes is proportional to their degree, with larger nodes having more connections</li>
<li>The layout of the network is determined by the WSBM algorithm, which arranges nodes based on their community assignments and interaction strengths</li>
<li>The color gradient represents the edge weights, with lighter colors indicating higher weights</li>
<li>The set of square nodes in the center of the network represents the reduced form (i.e., simplified) version of the network</li>
<li>The square nodes are arranged in a hierarchical structure, with each level representing a different level of community organization. In other words the square nodes in the outer layer are nested in the square nodes in the inner layer.</li>
</ul>
<!-- -->

</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Tiago P. Peixoto, “Nonparametric weighted stochastic block models”, Phys. Rev.&nbsp;E 97, 012306 (2018), DOI: 10.1103/PhysRevE.97.012306, arXiv: 1708.01432<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Paul W. Holland, Kathryn Blackmond Laskey, Samuel Leinhardt, “Stochastic blockmodels: First steps”, Social Networks Volume 5, Issue 2, Pages 109-137 (1983). DOI: 10.1016/0378-8733(83)90021-7<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Robert E. Ulanowicz, and Donald L. DeAngelis. “Network analysis of trophic dynamics in south florida ecosystems.” US Geological Survey Program on the South Florida Ecosystem 114 (2005).<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb5" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> Inferring the Modular Structure of Networks with Weighted Stochastic Blockmodeling </span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span><span class="co"> Simone Santoni</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> last-modified</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="an">abstract-title:</span><span class="co"> Synopsis</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="an">abstract:</span><span class="co"> This notebook shows how to infer the modular structure of weighted networks using the Weighted Stochastic Blockmodeling (WSBM) approach. WSBM extends the concept of the Stochastic Blockmodel (SBM) to incorporate edge weights into the modeling process, allowing for a more detailed representation of the network's structure. We will use a synthetic network dataset to illustrate the key steps involved in inferring the modular structure of a weighted network using the WSBM approach.</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="an">warning:</span><span class="co"> false</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="an">fig-cap-location:</span><span class="co"> top</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span><span class="co"> </span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co">  html:</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="co">    code-fold: true</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="co">    code-tools: true</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="co">    toc: true</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="co">    toc-title: Table of Contents </span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="co">    toc-depth: 2</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="co">    toc-location: right</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="co">    number-sections: true</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a><span class="co">    citations-hover: false</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="co">    footnotes-hover: false</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="co">    crossrefs-hover: false</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="co">    theme: journal</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="co">    fig-width: 9</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a><span class="co">    fig-height: 6</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="co">  ipynb: default</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a><span class="co">  docx: default</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a><span class="co">  typst:</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a><span class="co">    number-sections: true</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a><span class="co">    df-print: paged</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a><span class="co">  #pdf:</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a><span class="co">  #  documentclass: scrartcl</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a><span class="co">  #  papersize: letter</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a><span class="co">  #  papersize: letter</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a><span class="fu"># Overview: inferring the modular structure of networks</span></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>The notebook <span class="co">[</span><span class="ot">`community_detection.qmd`</span><span class="co">](https://github.com/simoneSantoni/net-analysis-smm638/blob/master/tutorials/networkModules/community_detection.qmd)</span> shows how to infer the modular structure of weighted networks using Louvain's community-detection algorithm. The current notebook focuses on a different approach to the same problem: the weighted stochastic blockmodeling (WSBM). </span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>WSBM<span class="ot">[^1]</span> approach is an extension of the stochastic blockmodel (SBM) that incorporates edge weights into the modeling process.<span class="ot">[^2]</span> SBMs are probabilistic models used to detect community structures in networks by partitioning nodes into blocks or communities, where the probability of an edge existing between any two nodes depends only on the blocks to which the nodes belong.</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a><span class="ot">[^1]: </span>Tiago P. Peixoto, “Nonparametric weighted stochastic block models”, Phys. Rev. E 97, 012306 (2018), DOI: 10.1103/PhysRevE.97.012306, arXiv: 1708.01432</span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a><span class="ot">[^2]: </span>Paul W. Holland, Kathryn Blackmond Laskey, Samuel Leinhardt, “Stochastic blockmodels: First steps”, Social Networks Volume 5, Issue 2, Pages 109-137 (1983). DOI: 10.1016/0378-8733(83)90021-7</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>WSBM extends this concept by considering not just the presence or absence of edges, but also the weights of the edges, which can represent the strength or capacity of connections between nodes. This allows for a more nuanced understanding of the network's structure, capturing variations in connection strengths within and between communities.</span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>The WSBM approach involves defining a likelihood function that accounts for the observed edge weights and optimizing this function to find the most likely partition of nodes into communities. This is typically done using techniques such as the Expectation-Maximization (EM) algorithm or variational inference.</span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>By incorporating edge weights, WSBM provides a more detailed and accurate representation of the network, making it particularly useful for analyzing weighted networks such as social networks with varying interaction strengths, biological networks with different interaction intensities, and transportation networks with different capacities. This approach enhances the ability to uncover meaningful community structures and understand the underlying processes governing the network.</span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>In this notebook, we will learn how to implement the WSBM approach using the <span class="in">`graph-tool`</span> library in Python. We will use a synthetic network dataset to illustrate the key steps involved in inferring the modular structure of a weighted network using the WSBM.</span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a><span class="fu"># Notebook setup</span></span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>We will use the <span class="in">`graph-tool`</span> library for network analysis and visualization. If you haven't already installed <span class="in">`graph-tool`</span>, you can do so using the following command:</span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a><span class="in">```{bash}</span></span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a><span class="ex">conda</span> activate %YOUR_ENVIRONMENT%</span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a><span class="ex">conda</span> install <span class="at">-c</span> conda-forge graph-tool</span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a>Then, we can import the necessary libraries and set up the notebook environment:</span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> Image</span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib</span>
<span id="cb5-72"><a href="#cb5-72" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> graph_tool.<span class="bu">all</span> <span class="im">import</span> <span class="op">*</span></span>
<span id="cb5-73"><a href="#cb5-73" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb5-74"><a href="#cb5-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-75"><a href="#cb5-75" aria-hidden="true" tabindex="-1"></a><span class="fu"># Toy Dataset: 'Food Web' network</span></span>
<span id="cb5-76"><a href="#cb5-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-77"><a href="#cb5-77" aria-hidden="true" tabindex="-1"></a>To illustrate the WSBM approach, we will use a synthetic network dataset representing a food web. The food web network consists of different species (nodes) connected by interactions (edges) representing predator-prey relationships. The edge weights in the network represent the strength of these interactions, with higher weights indicating stronger relationships.<span class="ot">[^3]</span> It is worth noticing that the edge values are positive $<span class="co">[</span><span class="ot">0, \infty</span><span class="co">]</span>$.</span>
<span id="cb5-78"><a href="#cb5-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-79"><a href="#cb5-79" aria-hidden="true" tabindex="-1"></a><span class="ot">[^3]: </span>Robert E. Ulanowicz, and Donald L. DeAngelis. “Network analysis of trophic dynamics in south florida ecosystems.” US Geological Survey Program on the South Florida Ecosystem 114 (2005).</span>
<span id="cb5-80"><a href="#cb5-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-83"><a href="#cb5-83" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb5-84"><a href="#cb5-84" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Food Web Network</span></span>
<span id="cb5-85"><a href="#cb5-85" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-width: 300</span></span>
<span id="cb5-86"><a href="#cb5-86" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap-location: margin</span></span>
<span id="cb5-87"><a href="#cb5-87" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-foodweb</span></span>
<span id="cb5-88"><a href="#cb5-88" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> collection.ns[<span class="st">"foodweb_baywet"</span>]</span>
<span id="cb5-89"><a href="#cb5-89" aria-hidden="true" tabindex="-1"></a>graph_draw(g, pos<span class="op">=</span>g.vp._pos, output_size<span class="op">=</span>(<span class="dv">300</span>, <span class="dv">300</span>), output<span class="op">=</span><span class="st">"foodweb.png"</span>)</span>
<span id="cb5-90"><a href="#cb5-90" aria-hidden="true" tabindex="-1"></a>Image(filename<span class="op">=</span><span class="st">"foodweb.png"</span>)</span>
<span id="cb5-91"><a href="#cb5-91" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb5-92"><a href="#cb5-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-93"><a href="#cb5-93" aria-hidden="true" tabindex="-1"></a>@fig-foodweb does not show a clear pattern. Let us see if we can uncover the underlying modular structure of this network using the WSBM approach.</span>
<span id="cb5-94"><a href="#cb5-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-95"><a href="#cb5-95" aria-hidden="true" tabindex="-1"></a><span class="fu"># Weighted Stochastic Blockmodeling (WSBM)</span></span>
<span id="cb5-96"><a href="#cb5-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-97"><a href="#cb5-97" aria-hidden="true" tabindex="-1"></a>The WSBM approach involves defining a likelihood function that accounts for the observed edge weights and optimizing this function to find the most likely partition of nodes into communities. As the following code cell shows, we can use the <span class="in">`graph-tool`</span> library to implement the WSBM approach for inferring the modular structure of the food web network. Specifically, we will use the <span class="in">`minimize_nested_blockmodel_dl`</span> function to fit the WSBM model to the network data. This function takes the following arguments in our example:</span>
<span id="cb5-98"><a href="#cb5-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-99"><a href="#cb5-99" aria-hidden="true" tabindex="-1"></a><span class="ss">+ </span><span class="in">`g`</span>: the input graph object representing the food web network</span>
<span id="cb5-100"><a href="#cb5-100" aria-hidden="true" tabindex="-1"></a><span class="ss">+ </span><span class="in">`state_args`</span>: a dictionary containing the edge weights (<span class="in">`recs`</span>) and their types (<span class="in">`rec_types`</span>) for the model fitting process</span>
<span id="cb5-101"><a href="#cb5-101" aria-hidden="true" tabindex="-1"></a><span class="ss">+ </span><span class="in">`rec_types`</span>: the type of edge weights, in this case, real-exponential -- remember that the edge values are positive!!</span>
<span id="cb5-102"><a href="#cb5-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-105"><a href="#cb5-105" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb5-106"><a href="#cb5-106" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Modular Structure of the Food Web Network Inferred Using WSBM</span></span>
<span id="cb5-107"><a href="#cb5-107" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-width: 300</span></span>
<span id="cb5-108"><a href="#cb5-108" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap-location: margin</span></span>
<span id="cb5-109"><a href="#cb5-109" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-foodweb-wsbm</span></span>
<span id="cb5-110"><a href="#cb5-110" aria-hidden="true" tabindex="-1"></a><span class="co"># model fit</span></span>
<span id="cb5-111"><a href="#cb5-111" aria-hidden="true" tabindex="-1"></a>state <span class="op">=</span> minimize_nested_blockmodel_dl(</span>
<span id="cb5-112"><a href="#cb5-112" aria-hidden="true" tabindex="-1"></a>    g, state_args<span class="op">=</span><span class="bu">dict</span>(recs<span class="op">=</span>[g.ep.weight], rec_types<span class="op">=</span>[<span class="st">"real-exponential"</span>])</span>
<span id="cb5-113"><a href="#cb5-113" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb5-114"><a href="#cb5-114" aria-hidden="true" tabindex="-1"></a><span class="co"># improve solution with merge-split</span></span>
<span id="cb5-115"><a href="#cb5-115" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">100</span>):</span>
<span id="cb5-116"><a href="#cb5-116" aria-hidden="true" tabindex="-1"></a>    ret <span class="op">=</span> state.multiflip_mcmc_sweep(niter<span class="op">=</span><span class="dv">10</span>, beta<span class="op">=</span>np.inf)</span>
<span id="cb5-117"><a href="#cb5-117" aria-hidden="true" tabindex="-1"></a>state.draw(</span>
<span id="cb5-118"><a href="#cb5-118" aria-hidden="true" tabindex="-1"></a>    edge_color<span class="op">=</span>prop_to_size(g.ep.weight, power<span class="op">=</span><span class="dv">1</span>, log<span class="op">=</span><span class="va">True</span>),</span>
<span id="cb5-119"><a href="#cb5-119" aria-hidden="true" tabindex="-1"></a>    ecmap<span class="op">=</span>(matplotlib.cm.inferno, <span class="fl">0.6</span>),</span>
<span id="cb5-120"><a href="#cb5-120" aria-hidden="true" tabindex="-1"></a>    eorder<span class="op">=</span>g.ep.weight,</span>
<span id="cb5-121"><a href="#cb5-121" aria-hidden="true" tabindex="-1"></a>    edge_pen_width<span class="op">=</span>prop_to_size(g.ep.weight, <span class="dv">1</span>, <span class="dv">4</span>, power<span class="op">=</span><span class="dv">1</span>, log<span class="op">=</span><span class="va">True</span>),</span>
<span id="cb5-122"><a href="#cb5-122" aria-hidden="true" tabindex="-1"></a>    edge_gradient<span class="op">=</span>[],</span>
<span id="cb5-123"><a href="#cb5-123" aria-hidden="true" tabindex="-1"></a>    output_size<span class="op">=</span>(<span class="dv">300</span>, <span class="dv">300</span>),</span>
<span id="cb5-124"><a href="#cb5-124" aria-hidden="true" tabindex="-1"></a>    output<span class="op">=</span><span class="st">"foodweb-wsbm.png"</span>,</span>
<span id="cb5-125"><a href="#cb5-125" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb5-126"><a href="#cb5-126" aria-hidden="true" tabindex="-1"></a><span class="co"># show the plot</span></span>
<span id="cb5-127"><a href="#cb5-127" aria-hidden="true" tabindex="-1"></a>Image(filename<span class="op">=</span><span class="st">"foodweb-wsbm.png"</span>)</span>
<span id="cb5-128"><a href="#cb5-128" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb5-129"><a href="#cb5-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-130"><a href="#cb5-130" aria-hidden="true" tabindex="-1"></a>@fig-foodweb-wsbm shows the modular structure of the food web network inferred using the WSBM approach. Quite evidently, this is a complex visualization:</span>
<span id="cb5-131"><a href="#cb5-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-132"><a href="#cb5-132" aria-hidden="true" tabindex="-1"></a><span class="ss">+ </span>The nodes are colored according to the community they belong to, with nodes of the same color representing the same community (that is, species dependent on the same resources)</span>
<span id="cb5-133"><a href="#cb5-133" aria-hidden="true" tabindex="-1"></a><span class="ss">+ </span>The size of nodes is proportional to their degree, with larger nodes having more connections</span>
<span id="cb5-134"><a href="#cb5-134" aria-hidden="true" tabindex="-1"></a><span class="ss">+ </span>The layout of the network is determined by the WSBM algorithm, which arranges nodes based on their community assignments and interaction strengths</span>
<span id="cb5-135"><a href="#cb5-135" aria-hidden="true" tabindex="-1"></a><span class="ss">+ </span>The color gradient represents the edge weights, with lighter colors indicating higher weights</span>
<span id="cb5-136"><a href="#cb5-136" aria-hidden="true" tabindex="-1"></a><span class="ss">+ </span>The set of square nodes in the center of the network represents the reduced form (i.e., simplified) version of the network</span>
<span id="cb5-137"><a href="#cb5-137" aria-hidden="true" tabindex="-1"></a><span class="ss">+ </span>The square nodes are arranged in a hierarchical structure, with each level representing a different level of community organization. In other words the square nodes in the outer layer are nested in the square nodes in the inner layer.</span>
</code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>
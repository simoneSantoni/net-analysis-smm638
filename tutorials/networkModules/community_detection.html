<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.37">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Simone Santoni">
<meta name="dcterms.date" content="2024-11-26">

<title>Community Detection</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="community_detection_files/libs/clipboard/clipboard.min.js"></script>
<script src="community_detection_files/libs/quarto-html/quarto.js"></script>
<script src="community_detection_files/libs/quarto-html/popper.min.js"></script>
<script src="community_detection_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="community_detection_files/libs/quarto-html/anchor.min.js"></script>
<link href="community_detection_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="community_detection_files/libs/quarto-html/quarto-syntax-highlighting-29e2c20b02301cfff04dc8050bf30c7e.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="community_detection_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="community_detection_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="community_detection_files/libs/bootstrap/bootstrap-45eab9f33756b4204ced05762ced8738.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of Contents</h2>
   
  <ul class="collapse">
  <li><a href="#notebook-setup" id="toc-notebook-setup" class="nav-link active" data-scroll-target="#notebook-setup"><span class="header-section-number">1</span> Notebook setup</a></li>
  <li><a href="#load-karate-club-network" id="toc-load-karate-club-network" class="nav-link" data-scroll-target="#load-karate-club-network"><span class="header-section-number">2</span> Load Karate Club network</a></li>
  <li><a href="#visualize-the-network" id="toc-visualize-the-network" class="nav-link" data-scroll-target="#visualize-the-network"><span class="header-section-number">3</span> Visualize the network</a></li>
  <li><a href="#community-detection-using-girvan-newmans-algorithm" id="toc-community-detection-using-girvan-newmans-algorithm" class="nav-link" data-scroll-target="#community-detection-using-girvan-newmans-algorithm"><span class="header-section-number">4</span> Community detection using Girvan-Newman’s algorithm</a></li>
  <li><a href="#community-detection-using-louvaines-algorithm" id="toc-community-detection-using-louvaines-algorithm" class="nav-link" data-scroll-target="#community-detection-using-louvaines-algorithm"><span class="header-section-number">5</span> Community detection using Louvaine’s algorithm</a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="community_detection.ipynb" download="community_detection.ipynb"><i class="bi bi-journal-code"></i>Jupyter</a></li><li><a href="community_detection.docx"><i class="bi bi-file-word"></i>MS Word</a></li><li><a href="../../community_detection.pdf"><i class="bi bi-file-pdf"></i>Typst</a></li></ul></div></nav>
</div>
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Community Detection</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Simone Santoni </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 26, 2024</p>
    </div>
  </div>
  
    
  </div>
  
<div>
  <div class="abstract">
    <div class="block-title">Synopsis</div>
    This notebook shows communities in a network — that is, groups of nodes densely connected to each others and sparsely connected with outgroup nodes. Specifically, the attention revolves around two popular community detection algorithms like Girvan-Newman and Louvain’s.
  </div>
</div>


</header>


<section id="notebook-setup" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Notebook setup</h1>
<p>For this tutorial, we rely on ‘usual suspects’ Python packages, like <code>numpy</code>, <code>matplotlib</code>, and <code>networkx</code>. The latter is the most popular Python package for the creation, manipulation, and study of the structure small to moderate size networks.</p>
<div id="7efae7fc" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="load-karate-club-network" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Load Karate Club network</h1>
<p>The Karate Club dataset is a well-known social network dataset representing the friendships between 34 members of a karate club at a US university in the 1970s<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. The network consists of 34 nodes and 78 edges, where nodes represent members and edges represent friendships. The dataset is often used for testing community detection algorithms, as it naturally splits into two communities due to a conflict between the club’s instructor and the administrator, leading to the formation of two separate clubs.</p>
<div id="5ea64e0a" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.karate_club_graph()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="visualize-the-network" class="level1 page-columns page-full" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Visualize the network</h1>
<p>The visual inspection of the network (see <a href="#fig-karate-club" class="quarto-xref">Figure&nbsp;1</a>) reveals two distinct groups of nodes that may correspond to two communities, i.e., groups of nodes that are more densely connected to each other than to nodes outside the group. Communities often represent functional units within the network, such as groups of friends in a social network, modules in a biological network, or clusters of related documents in an information network. However, we need to produce conclusive evidence that these groups are indeed communities.</p>
<div id="cell-fig-karate-club" class="cell page-columns page-full" data-fig-width="500" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3" data-cap-location="margin"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># fix node positions for better visualization</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> nx.spring_layout(G, seed<span class="op">=</span><span class="dv">123</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># draw the network</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>nx.draw(</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    G, pos, with_labels<span class="op">=</span><span class="va">True</span>, node_color<span class="op">=</span><span class="st">"lightgray"</span>, node_size<span class="op">=</span><span class="dv">300</span>, edge_color<span class="op">=</span><span class="st">"gray"</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display page-columns page-full">
<div id="fig-karate-club" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-cap-location="margin">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-karate-club-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="community_detection_files/figure-html/fig-karate-club-output-1.png" width="883" height="595" class="figure-img">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-karate-club-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Visualization of the Karate Club network
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="community-detection-using-girvan-newmans-algorithm" class="level1 page-columns page-full" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Community detection using Girvan-Newman’s algorithm</h1>
<p><code>networkx</code> provides an implementation of the Girvan-Newman<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> algorithm, which is a hierarchical clustering method based on edge betweenness centrality. The algorithm iteratively removes the edge with the highest betweenness centrality, recalculates the centrality of the remaining edges, and identifies the connected components of the graph. The process continues until the desired number of communities is reached.</p>
<p>Let us consider the first iteration of the Girvan-Newman algorithm, which consists of computing edge betweenness centrality. In <a href="#fig-karate-club-betweenness" class="quarto-xref">Figure&nbsp;2</a>), the edges are color-coded against their betweenness centrality values, with warmer colors indicating higher centrality.</p>
<div id="cell-fig-karate-club-betweenness" class="cell page-columns page-full" data-fig-width="500" data-execution_count="4">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4" data-cap-location="margin"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># edge betweenness centrality</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>edge_betweenness <span class="op">=</span> nx.edge_betweenness_centrality(G)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co"># network visualization</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>nx.draw(</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    G,</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    pos,</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    with_labels<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    node_color<span class="op">=</span><span class="st">"lightgray"</span>,</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    node_size<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    edgelist<span class="op">=</span>edge_betweenness.keys(),</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    edge_color<span class="op">=</span><span class="bu">list</span>(edge_betweenness.values()),</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    edge_cmap<span class="op">=</span>plt.cm.Reds,</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    edge_vmin<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    edge_vmax<span class="op">=</span><span class="fl">0.1</span>,</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display page-columns page-full">
<div id="fig-karate-club-betweenness" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-cap-location="margin">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-karate-club-betweenness-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="community_detection_files/figure-html/fig-karate-club-betweenness-output-1.png" width="883" height="595" class="figure-img">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-karate-club-betweenness-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Edge betweenness centrality in the Karate Club network
</figcaption>
</figure>
</div>
</div>
</div>
<p>The visual inspection of edge betweenness centrality suggests that the edge connecting nodes <code>0</code> and <code>31</code> has the highest centrality. We can check this by sorting the edges by centrality and examining the top five edges.</p>
<div id="4cbf83e4" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>edge_betweenness_sorted <span class="op">=</span> <span class="bu">sorted</span>(edge_betweenness.items(), key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(edge_betweenness_sorted[:<span class="dv">5</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[((0, 31), 0.1272599949070537), ((0, 6), 0.07813428401663695), ((0, 5), 0.07813428401663694), ((0, 2), 0.0777876807288572), ((0, 8), 0.07423959482783014)]</code></pre>
</div>
</div>
<p>The second step consists of removing the <code>0-31</code> and recalculating the centrality of the remaining edges. It is straight-forward that <code>G</code> will still be connected. In other words, we will not be able to see the two groups of nodes that get disconnected because of the removal one specific edge. Therefore, we will not have identified any partitioning of the network, that is, community structure. The process is repeated until the network breaks down into two connected components least.</p>
<div id="14d9a523" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># remove edge 0-31</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>G.remove_edge(<span class="dv">0</span>, <span class="dv">31</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co"># recalculate edge betweenness centrality</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>edge_betweenness <span class="op">=</span> nx.edge_betweenness_centrality(G)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co"># inspect the first 5 edges by centrality</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>edge_betweenness_sorted <span class="op">=</span> <span class="bu">sorted</span>(edge_betweenness.items(), key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(edge_betweenness_sorted[:<span class="dv">5</span>])</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co"># double check that the graph is still connected</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(nx.is_connected(G))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[((0, 2), 0.11924273983097515), ((0, 8), 0.09923105217222859), ((2, 32), 0.08791752909399968), ((13, 33), 0.08660576895871015), ((0, 5), 0.07813428401663694)]
True</code></pre>
</div>
</div>
<p><a href="#fig-karate-club-removed-edge" class="quarto-xref">Figure&nbsp;3</a> visualizes the network after removing the edge <code>0-31</code>. The two communities are clearly visible, with nodes <code>0</code> and <code>31</code> belonging to different groups.</p>
<div id="cell-fig-karate-club-removed-edge" class="cell page-columns page-full" data-execution_count="7">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9" data-cap-location="margin"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>nx.draw(</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    G,</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    pos,</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    with_labels<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    node_color<span class="op">=</span><span class="st">"lightgray"</span>,</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    node_size<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    edgelist<span class="op">=</span>edge_betweenness.keys(),</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    edge_color<span class="op">=</span><span class="bu">list</span>(edge_betweenness.values()),</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    edge_cmap<span class="op">=</span>plt.cm.Reds,</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    edge_vmin<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    edge_vmax<span class="op">=</span><span class="fl">0.1</span>,</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display page-columns page-full">
<div id="fig-karate-club-removed-edge" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-cap-location="margin">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-karate-club-removed-edge-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="community_detection_files/figure-html/fig-karate-club-removed-edge-output-1.png" width="883" height="595" class="figure-img">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-karate-club-removed-edge-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Visualization of the Karate Club network after removing the edge 0-31
</figcaption>
</figure>
</div>
</div>
</div>
<p>The intuition behind the Girvan-Newman algorithm is that edges connecting different communities have higher betweenness centrality, as they are crucial for connecting the communities. By iteratively removing these edges, the algorithm effectively identifies the communities in the network. For example, <a href="#fig-karate-club-removed-edge" class="quarto-xref">Figure&nbsp;3</a> shows the <code>G</code> is at risk to get disconnected if edges like <code>0-2</code>, <code>0-8</code>, and <code>19-33</code> are removed.</p>
<p>Luckily, <code>networkx</code> provides a convenient function <code>community.girvan_newman</code> to automate the process of community detection using the Girvan-Newman algorithm. The function returns an iterator over the discovered communities, allowing us to stop the algorithm at a specific number of communities. Let us apply the Girvan-Newman algorithm to the Karate Club network and visualize the communities.</p>
<div id="faf10cec" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># we must re-add the edge 0-31 to the graph</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>G.add_edge(<span class="dv">0</span>, <span class="dv">31</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Girvan-Newman algorithm</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>fit <span class="op">=</span> nx.community.girvan_newman(G)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="bu">tuple</span>(<span class="bu">sorted</span>(c) <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">next</span>(fit))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>([0, 1, 3, 4, 5, 6, 7, 10, 11, 12, 13, 16, 17, 19, 21],
 [2, 8, 9, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33])</code></pre>
</div>
</div>
<p>By default, the Girvan-Newman algorithm stops when the graph is partitioned into two communities. However, we can specify the desired number of communities by stopping the algorithm at a specific level. For example, we can stop the algorithm at the third level to obtain three communities.</p>
<div id="ae2ba2c7" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>fit <span class="op">=</span> nx.community.girvan_newman(G)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>limited <span class="op">=</span> itertools.takewhile(<span class="kw">lambda</span> c: <span class="bu">len</span>(c) <span class="op">&lt;=</span> k, fit)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> communities <span class="kw">in</span> limited:</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="bu">tuple</span>(<span class="bu">sorted</span>(c) <span class="cf">for</span> c <span class="kw">in</span> communities))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>([0, 1, 3, 4, 5, 6, 7, 10, 11, 12, 13, 16, 17, 19, 21], [2, 8, 9, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33])
([0, 1, 3, 4, 5, 6, 7, 10, 11, 12, 13, 16, 17, 19, 21], [2, 8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33], [9])
([0, 1, 3, 7, 11, 12, 13, 17, 19, 21], [2, 8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33], [4, 5, 6, 10, 16], [9])</code></pre>
</div>
</div>
<p>The visual inspection of Girvan-Newman’s algorithm outcome is a plausible place to start to adjudicate between alternative community structures.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> Let us start by visualizing the network with two communities (see <a href="#fig-karate-club-two-communities" class="quarto-xref">Figure&nbsp;4</a>).</p>
<div id="cell-fig-karate-club-two-communities" class="cell page-columns page-full" data-fig-width="500" data-execution_count="10">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14" data-cap-location="margin"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># fit the Girvan-Newman algorithm</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>fit <span class="op">=</span> nx.community.girvan_newman(G)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co"># we retain the first three partitions of the network</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co"># get the membership of the nodes into communities</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>limited <span class="op">=</span> itertools.takewhile(<span class="kw">lambda</span> c: <span class="bu">len</span>(c) <span class="op">&lt;=</span> k, fit)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>fits <span class="op">=</span> {}</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _, communities <span class="kw">in</span> <span class="bu">enumerate</span>(limited):</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    fits[_] <span class="op">=</span> <span class="bu">tuple</span>(<span class="bu">sorted</span>(c) <span class="cf">for</span> c <span class="kw">in</span> communities)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="co"># get the membership of the nodes into communities</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>two_communities <span class="op">=</span> fits[<span class="dv">0</span>]</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="co"># color code the communities</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [<span class="st">"plum"</span> <span class="cf">if</span> node <span class="kw">in</span> two_communities[<span class="dv">0</span>] <span class="cf">else</span> <span class="st">"lightgreen"</span> <span class="cf">for</span> node <span class="kw">in</span> G.nodes]</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="co"># visualize the network</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>nx.draw(</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    G,</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    pos,</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    with_labels<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    node_color<span class="op">=</span>colors,</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>    node_size<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>    edge_color<span class="op">=</span><span class="st">"gray"</span>,</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display page-columns page-full">
<div id="fig-karate-club-two-communities" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-cap-location="margin">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-karate-club-two-communities-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="community_detection_files/figure-html/fig-karate-club-two-communities-output-1.png" width="883" height="595" class="figure-img">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-karate-club-two-communities-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Visualization of the Karate Club network with two communities
</figcaption>
</figure>
</div>
</div>
</div>
<p>One may point out that the solution in <a href="#fig-karate-club-two-communities" class="quarto-xref">Figure&nbsp;4</a> presents a clear-cut division of the network into two communities. However, the division is not perfect, as some nodes are on the boundary between the two communities (see for example nodes <code>2</code> and <code>13</code>). This is a common issue in community detection, as nodes can have multiple connections to different communities. The Girvan-Newman algorithm is a divisive method that partitions the network into communities by removing edges, which may lead to suboptimal results.</p>
<p>The presence of boarder nodes is not the most concerning issue in this case, though. The lower-left section of <a href="#fig-karate-club-two-communities" class="quarto-xref">Figure&nbsp;4</a> indicates the presence of a group of nodes that are densely connected to each other but are not clearly part of the two main communities. Let us visualize the network with three communities to investigate this further.</p>
<div id="cell-fig-karate-club-three-communities" class="cell page-columns page-full" data-fig-width="500" data-execution_count="11">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15" data-cap-location="margin"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># color code the communities</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>three_communities <span class="op">=</span> fits[<span class="dv">1</span>]</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co"># print(three_communities)</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    (</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">"plum"</span> <span class="cf">if</span> node <span class="kw">in</span> three_communities[<span class="dv">0</span>]</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="st">"lightgreen"</span> <span class="cf">if</span> node <span class="kw">in</span> three_communities[<span class="dv">1</span>]</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="st">"lightblue"</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> node <span class="kw">in</span> G.nodes</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="co"># visualize the network</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>nx.draw(</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    G,</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    pos,</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    with_labels<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    node_color<span class="op">=</span>colors,</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    node_size<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    edge_color<span class="op">=</span><span class="st">"gray"</span>,</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display page-columns page-full">
<div id="fig-karate-club-three-communities" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-cap-location="margin">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-karate-club-three-communities-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="community_detection_files/figure-html/fig-karate-club-three-communities-output-1.png" width="883" height="595" class="figure-img">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-karate-club-three-communities-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: Visualization of the Karate Club network with three communities
</figcaption>
</figure>
</div>
</div>
</div>
<p>The three-community structure does not yield the expected representation of the network (in which nodes <code>4</code>, <code>5</code>, <code>6</code>, <code>10</code>, and <code>16</code> form their own community). Instead, it is node <code>9</code>, a ‘boarder’ node, that gets assigned to the third community. In light of this unsatisfactory solution, one may want to render and visualize the four-community structure (see <a href="#fig-karate-club-four-communities" class="quarto-xref">Figure&nbsp;6</a>).</p>
<div id="cell-fig-karate-club-four-communities" class="cell page-columns page-full" data-fig-width="500" data-execution_count="12">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16" data-cap-location="margin"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># color code the communities</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>four_communities <span class="op">=</span> fits[<span class="dv">2</span>]</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co"># print(three_communities)</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    (</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">"plum"</span> <span class="cf">if</span> node <span class="kw">in</span> four_communities[<span class="dv">0</span>]</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="st">"lightgreen"</span> <span class="cf">if</span> node <span class="kw">in</span> four_communities[<span class="dv">1</span>]</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="st">"orange"</span> <span class="cf">if</span> node <span class="kw">in</span> four_communities[<span class="dv">2</span>]</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="st">"lightblue"</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> node <span class="kw">in</span> G.nodes</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a><span class="co"># visualize the network</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>nx.draw(</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    G,</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    pos,</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    with_labels<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    node_color<span class="op">=</span>colors,</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    node_size<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    edge_color<span class="op">=</span><span class="st">"gray"</span>,</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display page-columns page-full">
<div id="fig-karate-club-four-communities" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-cap-location="margin">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-karate-club-four-communities-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="community_detection_files/figure-html/fig-karate-club-four-communities-output-1.png" width="883" height="595" class="figure-img">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-karate-club-four-communities-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6: Visualization of the Karate Club network with four communities
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="community-detection-using-louvaines-algorithm" class="level1 page-columns page-full" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Community detection using Louvaine’s algorithm</h1>
<p>The Louvain community detection algorithm<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> is a popular method for identifying communities in large networks. It is an iterative, modularity-based algorithm that optimizes the modularity of a partition of the network<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>. Modularity is a measure of the density of links inside communities compared to links between communities.</p>
<p>The algorithm operates in two main phases that are repeated iteratively. In the first phase, each node is assigned to its own community. Then, for each node, the algorithm considers moving it to the community of each of its neighbors, choosing the move that results in the highest increase (or smallest decrease) in modularity. This process is repeated for all nodes until no further improvement can be achieved.</p>
<p>In the second phase, the algorithm aggregates nodes belonging to the same community into a single node, creating a new, smaller network. Edges between the new nodes are weighted by the sum of the weights of the edges between the original nodes in the corresponding communities. The first phase is then reapplied to this new network.</p>
<p>These two phases are repeated iteratively until the modularity no longer increases significantly. The result is a hierarchical decomposition of the network into communities, which can be represented at different levels of granularity. The Louvain algorithm is efficient and can handle large networks, making it widely used in various applications, including social network analysis, biology, and information retrieval.</p>
<p>Let us consider an example of applying the Louvain algorithm to the Karate Club network. The <code>community</code> module in <code>networkx</code> provides an implementation of the Louvain algorithm, which we can use to detect communities in the network.</p>
<div id="16dee801" class="cell" data-execution_count="13">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Louvain algorithm fit</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>fit <span class="op">=</span> nx.community.louvain_communities(G)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co"># retriece the communities</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>communities <span class="op">=</span> <span class="bu">tuple</span>(<span class="bu">sorted</span>(c) <span class="cf">for</span> c <span class="kw">in</span> fit)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(communities)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>([0, 1, 2, 3, 7, 11, 12, 13, 17, 19, 21], [4, 5, 6, 10, 16], [23, 24, 25, 27, 28, 31], [8, 9, 14, 15, 18, 20, 22, 26, 29, 30, 32, 33])</code></pre>
</div>
</div>
<p>The community structure solution that maximizes the modularity criterion comprisese the following communities: <code>0, 1, 2, 3, 7, 13, 17, 19, 21</code> and <code>4, 5, 6, 10, 16</code> and <code>8, 9, 11, 12, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33</code>. The following <a href="#fig-karate-club-louvain-communities" class="quarto-xref">Figure&nbsp;7</a> visualize the network with the identified communities.</p>
<div id="cell-fig-karate-club-louvain-communities" class="cell page-columns page-full" data-fig-width="500" data-execution_count="14">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19" data-cap-location="margin"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    (</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">"plum"</span> <span class="cf">if</span> node <span class="kw">in</span> communities[<span class="dv">0</span>]</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="st">"lightgreen"</span> <span class="cf">if</span> node <span class="kw">in</span> communities[<span class="dv">1</span>]</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="st">"lightblue"</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> node <span class="kw">in</span> G.nodes</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="co"># visualize the network</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>nx.draw(</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    G,</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    pos,</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    with_labels<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    node_color<span class="op">=</span>colors,</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    node_size<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>    edge_color<span class="op">=</span><span class="st">"gray"</span>,</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display page-columns page-full">
<div id="fig-karate-club-louvain-communities" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-cap-location="margin">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-karate-club-louvain-communities-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="community_detection_files/figure-html/fig-karate-club-louvain-communities-output-1.png" width="883" height="595" class="figure-img">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-karate-club-louvain-communities-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7: Visualization of the Karate Club network with Louvain communities
</figcaption>
</figure>
</div>
</div>
</div>
<p>The Louvain algorithm is not only capable to isolate the most plausible community structure in a network. It can also handle weighted networks. Let us consider the case of a weighted Karate Club network, where the edge weights represent the strength of the friendship between members (see <a href="#fig-karate-club-weighted" class="quarto-xref">Figure&nbsp;8</a>). The following code snippet shows how to create a weighted version of the Karate Club network and apply the Louvain algorithm to detect communities.</p>
<div id="cell-fig-karate-club-weighted" class="cell page-columns page-full" data-fig-width="500" data-execution_count="15">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20" data-cap-location="margin"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># weighted Karate Club network</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>G_weighted <span class="op">=</span> nx.karate_club_graph()</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co"># assign random weights to the edges</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u, v <span class="kw">in</span> G_weighted.edges:</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    G_weighted[u][v][<span class="st">"weight"</span>] <span class="op">=</span> np.random.random_integers(<span class="dv">1</span>, <span class="dv">10</span>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="co"># visualize the weighted network</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>nx.draw(</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    G_weighted,</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    pos,</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    with_labels<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    node_color<span class="op">=</span><span class="st">"lightgray"</span>,</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    node_size<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    edge_color<span class="op">=</span>[G_weighted[u][v][<span class="st">"weight"</span>] <span class="cf">for</span> u, v <span class="kw">in</span> G_weighted.edges],</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    edge_cmap<span class="op">=</span>plt.cm.Greens,</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    edge_vmin<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    edge_vmax<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display page-columns page-full">
<div id="fig-karate-club-weighted" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-cap-location="margin">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-karate-club-weighted-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="community_detection_files/figure-html/fig-karate-club-weighted-output-1.png" width="883" height="595" class="figure-img">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-karate-club-weighted-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8: Visualization of the weighted Karate Club network
</figcaption>
</figure>
</div>
</div>
</div>
<p>Then, we fit the Louvain algorithm to the weighted network and visualize the communities — see <a href="#fig-karate-club-louvain-communities-weighted" class="quarto-xref">Figure&nbsp;9</a>.</p>
<div id="cell-fig-karate-club-louvain-communities-weighted" class="cell page-columns page-full" data-fig-width="500" data-execution_count="16">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21" data-cap-location="margin"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># fit the Louvain algorithm to the weighted network</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>fit <span class="op">=</span> nx.community.louvain_communities(G_weighted, weight<span class="op">=</span><span class="st">"weight"</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co"># retrieve the communities</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>communities <span class="op">=</span> <span class="bu">tuple</span>(<span class="bu">sorted</span>(c) <span class="cf">for</span> c <span class="kw">in</span> fit)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="co"># visualize the network with the identified communities</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    (</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>        <span class="st">"plum"</span> <span class="cf">if</span> node <span class="kw">in</span> communities[<span class="dv">0</span>]</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="st">"lightgreen"</span> <span class="cf">if</span> node <span class="kw">in</span> communities[<span class="dv">1</span>]</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="st">"lightblue"</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> node <span class="kw">in</span> G_weighted.nodes</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a><span class="co"># visualize the network</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>nx.draw(</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    G_weighted,</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>    pos,</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    with_labels<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>    node_color<span class="op">=</span>colors,</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>    node_size<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    edge_color<span class="op">=</span>[G_weighted[u][v][<span class="st">"weight"</span>] <span class="cf">for</span> u, v <span class="kw">in</span> G_weighted.edges],</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>    edge_cmap<span class="op">=</span>plt.cm.Greens,</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>    edge_vmin<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>    edge_vmax<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display page-columns page-full">
<div id="fig-karate-club-louvain-communities-weighted" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-cap-location="margin">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-karate-club-louvain-communities-weighted-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="community_detection_files/figure-html/fig-karate-club-louvain-communities-weighted-output-1.png" width="883" height="595" class="figure-img">
</div>
<figcaption class="quarto-float-caption-margin quarto-float-caption quarto-float-fig margin-caption" id="fig-karate-club-louvain-communities-weighted-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9: Visualization of the Karate Club network with Louvain communities in the weighted network
</figcaption>
</figure>
</div>
</div>
</div>
<p>Considering the weighted network, the Louvain algorithm yields some notable results:</p>
<ul>
<li>The strong ties between nodes <code>0</code>, <code>4</code>m, and <code>10</code> make nodes <code>0</code> and <code>4</code> part of the same community, despite the redundant ties to nodes <code>5</code>, <code>6</code> and <code>15</code> (compare <a href="#fig-karate-club-louvain-communities" class="quarto-xref">Figure&nbsp;7</a> and <a href="#fig-karate-club-louvain-communities-weighted" class="quarto-xref">Figure&nbsp;9</a>)</li>
<li>Nodes located at the boarder of the communities are more likely to be assigned to the community with which they share the strongest ties. For example, node <code>9</code> is assigned to the same community as node <code>30</code>; node <code>19</code> is assigned to to the same community as node <code>3</code>.</li>
</ul>
<!-- -->

</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Zachary, W. W. (1977). An information flow model for conflict and fission in small groups. Journal of anthropological research, 33(4), 452-473. doi:10.1086/jar.33.4.3629752<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Girvan, M., &amp; Newman, M. E. J. (2002). Community structure in social and biological networks. Proceedings of the National Academy of Sciences, 99(12), 7821-7826. doi:10.1073/pnas.122653799<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>It is worth noticing that Girvan-Newman’s algorithm is not deterministic, and the results may vary depending on the initial conditions and the order in which edges are removed. Therefore, it is essential to consider multiple runs of the algorithm and compare the results to identify robust communities.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Blondel, V. D., Guillaume, J. L., Lambiotte, R., &amp; Lefebvre, E. (2008). Fast unfolding of communities in large networks. Journal of Statistical Mechanics: Theory and Experiment, 2008(10), P10008. doi:10.1088/1742-5468/2008/10/P10008<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Nicolas Dugué, Anthony Perez. Directed Louvain : maximizing modularity in directed networks. [Research Report] Université d’Orléans. 2015. hal-01231784. https://hal.archives-ouvertes.fr/hal-01231784<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb22" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> Community Detection </span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span><span class="co"> Simone Santoni</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> last-modified</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="an">abstract-title:</span><span class="co"> Synopsis</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="an">abstract:</span><span class="co"> This notebook shows communities in a network --- that is, groups of nodes densely connected to each others and sparsely connected with outgroup nodes. Specifically, the attention revolves around two popular community detection algorithms like Girvan-Newman and Louvain's. </span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="an">warning:</span><span class="co"> false</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="an">fig-cap-location:</span><span class="co"> top</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span><span class="co"> </span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="co">  html:</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="co">    code-fold: true</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="co">    code-tools: true</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a><span class="co">    toc: true</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a><span class="co">    toc-title: Table of Contents </span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a><span class="co">    toc-depth: 2</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a><span class="co">    toc-location: right</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a><span class="co">    number-sections: true</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a><span class="co">    citations-hover: false</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a><span class="co">    footnotes-hover: false</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a><span class="co">    crossrefs-hover: false</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a><span class="co">    theme: journal</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a><span class="co">    fig-width: 9</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a><span class="co">    fig-height: 6</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a><span class="co">  ipynb: default</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a><span class="co">  docx: default</span></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a><span class="co">  typst:</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a><span class="co">    number-sections: true</span></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a><span class="co">    df-print: paged</span></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a><span class="co">  #pdf:</span></span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a><span class="co">  #  documentclass: scrartcl</span></span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a><span class="co">  #  papersize: letter</span></span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a><span class="co">  #  papersize: letter</span></span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a><span class="fu"># Notebook setup</span></span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>For this tutorial, we rely on 'usual suspects' Python packages, like <span class="in">`numpy`</span>, <span class="in">`matplotlib`</span>, and <span class="in">`networkx`</span>. The latter is the most popular Python package for the creation, manipulation, and study of the structure small to moderate size networks.</span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-46"><a href="#cb22-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-47"><a href="#cb22-47" aria-hidden="true" tabindex="-1"></a><span class="fu"># Load Karate Club network</span></span>
<span id="cb22-48"><a href="#cb22-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-49"><a href="#cb22-49" aria-hidden="true" tabindex="-1"></a>The Karate Club dataset is a well-known social network dataset representing the friendships between 34 members of a karate club at a US university in the 1970s<span class="ot">[^0]</span>. The network consists of 34 nodes and 78 edges, where nodes represent members and edges represent friendships. The dataset is often used for testing community detection algorithms, as it naturally splits into two communities due to a conflict between the club's instructor and the administrator, leading to the formation of two separate clubs.</span>
<span id="cb22-50"><a href="#cb22-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-51"><a href="#cb22-51" aria-hidden="true" tabindex="-1"></a><span class="ot">[^0]: </span>Zachary, W. W. (1977). An information flow model for conflict and fission in small groups. Journal of anthropological research, 33(4), 452-473. doi:10.1086/jar.33.4.3629752</span>
<span id="cb22-52"><a href="#cb22-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-55"><a href="#cb22-55" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb22-56"><a href="#cb22-56" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.karate_club_graph()</span>
<span id="cb22-57"><a href="#cb22-57" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-58"><a href="#cb22-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-59"><a href="#cb22-59" aria-hidden="true" tabindex="-1"></a><span class="fu"># Visualize the network</span></span>
<span id="cb22-60"><a href="#cb22-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-61"><a href="#cb22-61" aria-hidden="true" tabindex="-1"></a>The visual inspection of the network (see @fig-karate-club) reveals two distinct groups of nodes that may correspond to two communities, i.e., groups of nodes that are more densely connected to each other than to nodes outside the group. Communities often represent functional units within the network, such as groups of friends in a social network, modules in a biological network, or clusters of related documents in an information network. However, we need to produce conclusive evidence that these groups are indeed communities.</span>
<span id="cb22-62"><a href="#cb22-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-65"><a href="#cb22-65" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb22-66"><a href="#cb22-66" aria-hidden="true" tabindex="-1"></a><span class="co"># | fig-cap: Visualization of the Karate Club network</span></span>
<span id="cb22-67"><a href="#cb22-67" aria-hidden="true" tabindex="-1"></a><span class="co"># | label: fig-karate-club</span></span>
<span id="cb22-68"><a href="#cb22-68" aria-hidden="true" tabindex="-1"></a><span class="co"># | fig-cap-location: margin</span></span>
<span id="cb22-69"><a href="#cb22-69" aria-hidden="true" tabindex="-1"></a><span class="co"># | fig-width: 500</span></span>
<span id="cb22-70"><a href="#cb22-70" aria-hidden="true" tabindex="-1"></a><span class="co"># fix node positions for better visualization</span></span>
<span id="cb22-71"><a href="#cb22-71" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> nx.spring_layout(G, seed<span class="op">=</span><span class="dv">123</span>)</span>
<span id="cb22-72"><a href="#cb22-72" aria-hidden="true" tabindex="-1"></a><span class="co"># draw the network</span></span>
<span id="cb22-73"><a href="#cb22-73" aria-hidden="true" tabindex="-1"></a>nx.draw(</span>
<span id="cb22-74"><a href="#cb22-74" aria-hidden="true" tabindex="-1"></a>    G, pos, with_labels<span class="op">=</span><span class="va">True</span>, node_color<span class="op">=</span><span class="st">"lightgray"</span>, node_size<span class="op">=</span><span class="dv">300</span>, edge_color<span class="op">=</span><span class="st">"gray"</span></span>
<span id="cb22-75"><a href="#cb22-75" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb22-76"><a href="#cb22-76" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-77"><a href="#cb22-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-78"><a href="#cb22-78" aria-hidden="true" tabindex="-1"></a><span class="fu"># Community detection using Girvan-Newman's algorithm</span></span>
<span id="cb22-79"><a href="#cb22-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-80"><a href="#cb22-80" aria-hidden="true" tabindex="-1"></a><span class="in">`networkx`</span> provides an implementation of the Girvan-Newman<span class="ot">[^1]</span> algorithm, which is a hierarchical clustering method based on edge betweenness centrality. The algorithm iteratively removes the edge with the highest betweenness centrality, recalculates the centrality of the remaining edges, and identifies the connected components of the graph. The process continues until the desired number of communities is reached.</span>
<span id="cb22-81"><a href="#cb22-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-82"><a href="#cb22-82" aria-hidden="true" tabindex="-1"></a><span class="ot">[^1]: </span>Girvan, M., &amp; Newman, M. E. J. (2002). Community structure in social and biological networks. Proceedings of the National Academy of Sciences, 99(12), 7821-7826. doi:10.1073/pnas.122653799</span>
<span id="cb22-83"><a href="#cb22-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-84"><a href="#cb22-84" aria-hidden="true" tabindex="-1"></a>Let us consider the first iteration of the Girvan-Newman algorithm, which consists of computing edge betweenness centrality. In @fig-karate-club-betweenness), the edges are color-coded against their betweenness centrality values, with warmer colors indicating higher centrality. </span>
<span id="cb22-85"><a href="#cb22-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-88"><a href="#cb22-88" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb22-89"><a href="#cb22-89" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Edge betweenness centrality in the Karate Club network</span></span>
<span id="cb22-90"><a href="#cb22-90" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-karate-club-betweenness</span></span>
<span id="cb22-91"><a href="#cb22-91" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap-location: margin</span></span>
<span id="cb22-92"><a href="#cb22-92" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-width: 500</span></span>
<span id="cb22-93"><a href="#cb22-93" aria-hidden="true" tabindex="-1"></a><span class="co"># edge betweenness centrality</span></span>
<span id="cb22-94"><a href="#cb22-94" aria-hidden="true" tabindex="-1"></a>edge_betweenness <span class="op">=</span> nx.edge_betweenness_centrality(G)</span>
<span id="cb22-95"><a href="#cb22-95" aria-hidden="true" tabindex="-1"></a><span class="co"># network visualization</span></span>
<span id="cb22-96"><a href="#cb22-96" aria-hidden="true" tabindex="-1"></a>nx.draw(</span>
<span id="cb22-97"><a href="#cb22-97" aria-hidden="true" tabindex="-1"></a>    G,</span>
<span id="cb22-98"><a href="#cb22-98" aria-hidden="true" tabindex="-1"></a>    pos,</span>
<span id="cb22-99"><a href="#cb22-99" aria-hidden="true" tabindex="-1"></a>    with_labels<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb22-100"><a href="#cb22-100" aria-hidden="true" tabindex="-1"></a>    node_color<span class="op">=</span><span class="st">"lightgray"</span>,</span>
<span id="cb22-101"><a href="#cb22-101" aria-hidden="true" tabindex="-1"></a>    node_size<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb22-102"><a href="#cb22-102" aria-hidden="true" tabindex="-1"></a>    edgelist<span class="op">=</span>edge_betweenness.keys(),</span>
<span id="cb22-103"><a href="#cb22-103" aria-hidden="true" tabindex="-1"></a>    edge_color<span class="op">=</span><span class="bu">list</span>(edge_betweenness.values()),</span>
<span id="cb22-104"><a href="#cb22-104" aria-hidden="true" tabindex="-1"></a>    edge_cmap<span class="op">=</span>plt.cm.Reds,</span>
<span id="cb22-105"><a href="#cb22-105" aria-hidden="true" tabindex="-1"></a>    edge_vmin<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb22-106"><a href="#cb22-106" aria-hidden="true" tabindex="-1"></a>    edge_vmax<span class="op">=</span><span class="fl">0.1</span>,</span>
<span id="cb22-107"><a href="#cb22-107" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb22-108"><a href="#cb22-108" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-109"><a href="#cb22-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-110"><a href="#cb22-110" aria-hidden="true" tabindex="-1"></a>The visual inspection of edge betweenness centrality suggests that the edge connecting nodes <span class="in">`0`</span> and <span class="in">`31`</span> has the highest centrality. We can check this by sorting the edges by centrality and examining the top five edges.</span>
<span id="cb22-111"><a href="#cb22-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-114"><a href="#cb22-114" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb22-115"><a href="#cb22-115" aria-hidden="true" tabindex="-1"></a>edge_betweenness_sorted <span class="op">=</span> <span class="bu">sorted</span>(edge_betweenness.items(), key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb22-116"><a href="#cb22-116" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(edge_betweenness_sorted[:<span class="dv">5</span>])</span>
<span id="cb22-117"><a href="#cb22-117" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-118"><a href="#cb22-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-119"><a href="#cb22-119" aria-hidden="true" tabindex="-1"></a>The second step consists of removing the <span class="in">`0-31`</span> and recalculating the centrality of the remaining edges. It is straight-forward that <span class="in">`G`</span> will still be connected. In other words, we will not be able to see the two groups of nodes that get disconnected because of the removal one specific edge. Therefore, we will not have identified any partitioning of the network, that is, community structure. The process is repeated until the network breaks down into two connected components least.</span>
<span id="cb22-120"><a href="#cb22-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-123"><a href="#cb22-123" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb22-124"><a href="#cb22-124" aria-hidden="true" tabindex="-1"></a><span class="co"># remove edge 0-31</span></span>
<span id="cb22-125"><a href="#cb22-125" aria-hidden="true" tabindex="-1"></a>G.remove_edge(<span class="dv">0</span>, <span class="dv">31</span>)</span>
<span id="cb22-126"><a href="#cb22-126" aria-hidden="true" tabindex="-1"></a><span class="co"># recalculate edge betweenness centrality</span></span>
<span id="cb22-127"><a href="#cb22-127" aria-hidden="true" tabindex="-1"></a>edge_betweenness <span class="op">=</span> nx.edge_betweenness_centrality(G)</span>
<span id="cb22-128"><a href="#cb22-128" aria-hidden="true" tabindex="-1"></a><span class="co"># inspect the first 5 edges by centrality</span></span>
<span id="cb22-129"><a href="#cb22-129" aria-hidden="true" tabindex="-1"></a>edge_betweenness_sorted <span class="op">=</span> <span class="bu">sorted</span>(edge_betweenness.items(), key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb22-130"><a href="#cb22-130" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(edge_betweenness_sorted[:<span class="dv">5</span>])</span>
<span id="cb22-131"><a href="#cb22-131" aria-hidden="true" tabindex="-1"></a><span class="co"># double check that the graph is still connected</span></span>
<span id="cb22-132"><a href="#cb22-132" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(nx.is_connected(G))</span>
<span id="cb22-133"><a href="#cb22-133" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-134"><a href="#cb22-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-135"><a href="#cb22-135" aria-hidden="true" tabindex="-1"></a>@fig-karate-club-removed-edge visualizes the network after removing the edge <span class="in">`0-31`</span>. The two communities are clearly visible, with nodes <span class="in">`0`</span> and <span class="in">`31`</span> belonging to different groups.</span>
<span id="cb22-136"><a href="#cb22-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-139"><a href="#cb22-139" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb22-140"><a href="#cb22-140" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Visualization of the Karate Club network after removing the edge 0-31</span></span>
<span id="cb22-141"><a href="#cb22-141" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-karate-club-removed-edge</span></span>
<span id="cb22-142"><a href="#cb22-142" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap-location: margin</span></span>
<span id="cb22-143"><a href="#cb22-143" aria-hidden="true" tabindex="-1"></a>nx.draw(</span>
<span id="cb22-144"><a href="#cb22-144" aria-hidden="true" tabindex="-1"></a>    G,</span>
<span id="cb22-145"><a href="#cb22-145" aria-hidden="true" tabindex="-1"></a>    pos,</span>
<span id="cb22-146"><a href="#cb22-146" aria-hidden="true" tabindex="-1"></a>    with_labels<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb22-147"><a href="#cb22-147" aria-hidden="true" tabindex="-1"></a>    node_color<span class="op">=</span><span class="st">"lightgray"</span>,</span>
<span id="cb22-148"><a href="#cb22-148" aria-hidden="true" tabindex="-1"></a>    node_size<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb22-149"><a href="#cb22-149" aria-hidden="true" tabindex="-1"></a>    edgelist<span class="op">=</span>edge_betweenness.keys(),</span>
<span id="cb22-150"><a href="#cb22-150" aria-hidden="true" tabindex="-1"></a>    edge_color<span class="op">=</span><span class="bu">list</span>(edge_betweenness.values()),</span>
<span id="cb22-151"><a href="#cb22-151" aria-hidden="true" tabindex="-1"></a>    edge_cmap<span class="op">=</span>plt.cm.Reds,</span>
<span id="cb22-152"><a href="#cb22-152" aria-hidden="true" tabindex="-1"></a>    edge_vmin<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb22-153"><a href="#cb22-153" aria-hidden="true" tabindex="-1"></a>    edge_vmax<span class="op">=</span><span class="fl">0.1</span>,</span>
<span id="cb22-154"><a href="#cb22-154" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb22-155"><a href="#cb22-155" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-156"><a href="#cb22-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-157"><a href="#cb22-157" aria-hidden="true" tabindex="-1"></a>The intuition behind the Girvan-Newman algorithm is that edges connecting different communities have higher betweenness centrality, as they are crucial for connecting the communities. By iteratively removing these edges, the algorithm effectively identifies the communities in the network. For example, @fig-karate-club-removed-edge shows the <span class="in">`G`</span> is at risk to get disconnected if edges like <span class="in">`0-2`</span>, <span class="in">`0-8`</span>, and <span class="in">`19-33`</span> are removed.</span>
<span id="cb22-158"><a href="#cb22-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-159"><a href="#cb22-159" aria-hidden="true" tabindex="-1"></a>Luckily, <span class="in">`networkx`</span> provides a convenient function <span class="in">`community.girvan_newman`</span> to automate the process of community detection using the Girvan-Newman algorithm. The function returns an iterator over the discovered communities, allowing us to stop the algorithm at a specific number of communities. Let us apply the Girvan-Newman algorithm to the Karate Club network and visualize the communities.</span>
<span id="cb22-160"><a href="#cb22-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-163"><a href="#cb22-163" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb22-164"><a href="#cb22-164" aria-hidden="true" tabindex="-1"></a><span class="co"># we must re-add the edge 0-31 to the graph</span></span>
<span id="cb22-165"><a href="#cb22-165" aria-hidden="true" tabindex="-1"></a>G.add_edge(<span class="dv">0</span>, <span class="dv">31</span>)</span>
<span id="cb22-166"><a href="#cb22-166" aria-hidden="true" tabindex="-1"></a><span class="co"># Girvan-Newman algorithm</span></span>
<span id="cb22-167"><a href="#cb22-167" aria-hidden="true" tabindex="-1"></a>fit <span class="op">=</span> nx.community.girvan_newman(G)</span>
<span id="cb22-168"><a href="#cb22-168" aria-hidden="true" tabindex="-1"></a><span class="bu">tuple</span>(<span class="bu">sorted</span>(c) <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">next</span>(fit))</span>
<span id="cb22-169"><a href="#cb22-169" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-170"><a href="#cb22-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-171"><a href="#cb22-171" aria-hidden="true" tabindex="-1"></a>By default, the Girvan-Newman algorithm stops when the graph is partitioned into two communities. However, we can specify the desired number of communities by stopping the algorithm at a specific level. For example, we can stop the algorithm at the third level to obtain three communities.</span>
<span id="cb22-172"><a href="#cb22-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-175"><a href="#cb22-175" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb22-176"><a href="#cb22-176" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools</span>
<span id="cb22-177"><a href="#cb22-177" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb22-178"><a href="#cb22-178" aria-hidden="true" tabindex="-1"></a>fit <span class="op">=</span> nx.community.girvan_newman(G)</span>
<span id="cb22-179"><a href="#cb22-179" aria-hidden="true" tabindex="-1"></a>limited <span class="op">=</span> itertools.takewhile(<span class="kw">lambda</span> c: <span class="bu">len</span>(c) <span class="op">&lt;=</span> k, fit)</span>
<span id="cb22-180"><a href="#cb22-180" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> communities <span class="kw">in</span> limited:</span>
<span id="cb22-181"><a href="#cb22-181" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="bu">tuple</span>(<span class="bu">sorted</span>(c) <span class="cf">for</span> c <span class="kw">in</span> communities))</span>
<span id="cb22-182"><a href="#cb22-182" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-183"><a href="#cb22-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-184"><a href="#cb22-184" aria-hidden="true" tabindex="-1"></a>The visual inspection of Girvan-Newman's algorithm outcome is a plausible place to start to adjudicate between alternative community structures.<span class="ot">[^2]</span> Let us start by visualizing the network with two communities (see @fig-karate-club-two-communities).</span>
<span id="cb22-185"><a href="#cb22-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-186"><a href="#cb22-186" aria-hidden="true" tabindex="-1"></a><span class="ot">[^2]: </span>It is worth noticing that Girvan-Newman's algorithm is not deterministic, and the results may vary depending on the initial conditions and the order in which edges are removed. Therefore, it is essential to consider multiple runs of the algorithm and compare the results to identify robust communities.</span>
<span id="cb22-187"><a href="#cb22-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-190"><a href="#cb22-190" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb22-191"><a href="#cb22-191" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Visualization of the Karate Club network with two communities</span></span>
<span id="cb22-192"><a href="#cb22-192" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap-location: margin</span></span>
<span id="cb22-193"><a href="#cb22-193" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-width: 500</span></span>
<span id="cb22-194"><a href="#cb22-194" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-karate-club-two-communities</span></span>
<span id="cb22-195"><a href="#cb22-195" aria-hidden="true" tabindex="-1"></a><span class="co"># fit the Girvan-Newman algorithm</span></span>
<span id="cb22-196"><a href="#cb22-196" aria-hidden="true" tabindex="-1"></a>fit <span class="op">=</span> nx.community.girvan_newman(G)</span>
<span id="cb22-197"><a href="#cb22-197" aria-hidden="true" tabindex="-1"></a><span class="co"># we retain the first three partitions of the network</span></span>
<span id="cb22-198"><a href="#cb22-198" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb22-199"><a href="#cb22-199" aria-hidden="true" tabindex="-1"></a><span class="co"># get the membership of the nodes into communities</span></span>
<span id="cb22-200"><a href="#cb22-200" aria-hidden="true" tabindex="-1"></a>limited <span class="op">=</span> itertools.takewhile(<span class="kw">lambda</span> c: <span class="bu">len</span>(c) <span class="op">&lt;=</span> k, fit)</span>
<span id="cb22-201"><a href="#cb22-201" aria-hidden="true" tabindex="-1"></a>fits <span class="op">=</span> {}</span>
<span id="cb22-202"><a href="#cb22-202" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _, communities <span class="kw">in</span> <span class="bu">enumerate</span>(limited):</span>
<span id="cb22-203"><a href="#cb22-203" aria-hidden="true" tabindex="-1"></a>    fits[_] <span class="op">=</span> <span class="bu">tuple</span>(<span class="bu">sorted</span>(c) <span class="cf">for</span> c <span class="kw">in</span> communities)</span>
<span id="cb22-204"><a href="#cb22-204" aria-hidden="true" tabindex="-1"></a><span class="co"># get the membership of the nodes into communities</span></span>
<span id="cb22-205"><a href="#cb22-205" aria-hidden="true" tabindex="-1"></a>two_communities <span class="op">=</span> fits[<span class="dv">0</span>]</span>
<span id="cb22-206"><a href="#cb22-206" aria-hidden="true" tabindex="-1"></a><span class="co"># color code the communities</span></span>
<span id="cb22-207"><a href="#cb22-207" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [<span class="st">"plum"</span> <span class="cf">if</span> node <span class="kw">in</span> two_communities[<span class="dv">0</span>] <span class="cf">else</span> <span class="st">"lightgreen"</span> <span class="cf">for</span> node <span class="kw">in</span> G.nodes]</span>
<span id="cb22-208"><a href="#cb22-208" aria-hidden="true" tabindex="-1"></a><span class="co"># visualize the network</span></span>
<span id="cb22-209"><a href="#cb22-209" aria-hidden="true" tabindex="-1"></a>nx.draw(</span>
<span id="cb22-210"><a href="#cb22-210" aria-hidden="true" tabindex="-1"></a>    G,</span>
<span id="cb22-211"><a href="#cb22-211" aria-hidden="true" tabindex="-1"></a>    pos,</span>
<span id="cb22-212"><a href="#cb22-212" aria-hidden="true" tabindex="-1"></a>    with_labels<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb22-213"><a href="#cb22-213" aria-hidden="true" tabindex="-1"></a>    node_color<span class="op">=</span>colors,</span>
<span id="cb22-214"><a href="#cb22-214" aria-hidden="true" tabindex="-1"></a>    node_size<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb22-215"><a href="#cb22-215" aria-hidden="true" tabindex="-1"></a>    edge_color<span class="op">=</span><span class="st">"gray"</span>,</span>
<span id="cb22-216"><a href="#cb22-216" aria-hidden="true" tabindex="-1"></a>) </span>
<span id="cb22-217"><a href="#cb22-217" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-218"><a href="#cb22-218" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-219"><a href="#cb22-219" aria-hidden="true" tabindex="-1"></a>One may point out that the solution in @fig-karate-club-two-communities presents a clear-cut division of the network into two communities. However, the division is not perfect, as some nodes are on the boundary between the two communities (see for example nodes <span class="in">`2`</span> and <span class="in">`13`</span>). This is a common issue in community detection, as nodes can have multiple connections to different communities. The Girvan-Newman algorithm is a divisive method that partitions the network into communities by removing edges, which may lead to suboptimal results. </span>
<span id="cb22-220"><a href="#cb22-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-221"><a href="#cb22-221" aria-hidden="true" tabindex="-1"></a>The presence of boarder nodes is not the most concerning issue in this case, though. The lower-left section of @fig-karate-club-two-communities indicates the presence of a group of nodes that are densely connected to each other but are not clearly part of the two main communities. Let us visualize the network with three communities to investigate this further.</span>
<span id="cb22-222"><a href="#cb22-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-225"><a href="#cb22-225" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb22-226"><a href="#cb22-226" aria-hidden="true" tabindex="-1"></a><span class="co"># | fig-cap: Visualization of the Karate Club network with three communities</span></span>
<span id="cb22-227"><a href="#cb22-227" aria-hidden="true" tabindex="-1"></a><span class="co"># | fig-cap-location: margin</span></span>
<span id="cb22-228"><a href="#cb22-228" aria-hidden="true" tabindex="-1"></a><span class="co"># | fig-width: 500</span></span>
<span id="cb22-229"><a href="#cb22-229" aria-hidden="true" tabindex="-1"></a><span class="co"># | label: fig-karate-club-three-communities</span></span>
<span id="cb22-230"><a href="#cb22-230" aria-hidden="true" tabindex="-1"></a><span class="co"># color code the communities</span></span>
<span id="cb22-231"><a href="#cb22-231" aria-hidden="true" tabindex="-1"></a>three_communities <span class="op">=</span> fits[<span class="dv">1</span>]</span>
<span id="cb22-232"><a href="#cb22-232" aria-hidden="true" tabindex="-1"></a><span class="co"># print(three_communities)</span></span>
<span id="cb22-233"><a href="#cb22-233" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [</span>
<span id="cb22-234"><a href="#cb22-234" aria-hidden="true" tabindex="-1"></a>    (</span>
<span id="cb22-235"><a href="#cb22-235" aria-hidden="true" tabindex="-1"></a>        <span class="st">"plum"</span> <span class="cf">if</span> node <span class="kw">in</span> three_communities[<span class="dv">0</span>]</span>
<span id="cb22-236"><a href="#cb22-236" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="st">"lightgreen"</span> <span class="cf">if</span> node <span class="kw">in</span> three_communities[<span class="dv">1</span>]</span>
<span id="cb22-237"><a href="#cb22-237" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="st">"lightblue"</span></span>
<span id="cb22-238"><a href="#cb22-238" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb22-239"><a href="#cb22-239" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> node <span class="kw">in</span> G.nodes</span>
<span id="cb22-240"><a href="#cb22-240" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb22-241"><a href="#cb22-241" aria-hidden="true" tabindex="-1"></a><span class="co"># visualize the network</span></span>
<span id="cb22-242"><a href="#cb22-242" aria-hidden="true" tabindex="-1"></a>nx.draw(</span>
<span id="cb22-243"><a href="#cb22-243" aria-hidden="true" tabindex="-1"></a>    G,</span>
<span id="cb22-244"><a href="#cb22-244" aria-hidden="true" tabindex="-1"></a>    pos,</span>
<span id="cb22-245"><a href="#cb22-245" aria-hidden="true" tabindex="-1"></a>    with_labels<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb22-246"><a href="#cb22-246" aria-hidden="true" tabindex="-1"></a>    node_color<span class="op">=</span>colors,</span>
<span id="cb22-247"><a href="#cb22-247" aria-hidden="true" tabindex="-1"></a>    node_size<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb22-248"><a href="#cb22-248" aria-hidden="true" tabindex="-1"></a>    edge_color<span class="op">=</span><span class="st">"gray"</span>,</span>
<span id="cb22-249"><a href="#cb22-249" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb22-250"><a href="#cb22-250" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-251"><a href="#cb22-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-252"><a href="#cb22-252" aria-hidden="true" tabindex="-1"></a>The three-community structure does not yield the expected representation of the network (in which nodes <span class="in">`4`</span>, <span class="in">`5`</span>, <span class="in">`6`</span>, <span class="in">`10`</span>, and <span class="in">`16`</span> form their own community). Instead, it is node <span class="in">`9`</span>, a 'boarder' node, that gets assigned to the third community. In light of this unsatisfactory solution, one may want to render and visualize the four-community structure (see @fig-karate-club-four-communities).</span>
<span id="cb22-253"><a href="#cb22-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-256"><a href="#cb22-256" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb22-257"><a href="#cb22-257" aria-hidden="true" tabindex="-1"></a><span class="co"># | fig-cap: Visualization of the Karate Club network with four communities</span></span>
<span id="cb22-258"><a href="#cb22-258" aria-hidden="true" tabindex="-1"></a><span class="co"># | fig-cap-location: margin</span></span>
<span id="cb22-259"><a href="#cb22-259" aria-hidden="true" tabindex="-1"></a><span class="co"># | fig-width: 500</span></span>
<span id="cb22-260"><a href="#cb22-260" aria-hidden="true" tabindex="-1"></a><span class="co"># | label: fig-karate-club-four-communities</span></span>
<span id="cb22-261"><a href="#cb22-261" aria-hidden="true" tabindex="-1"></a><span class="co"># color code the communities</span></span>
<span id="cb22-262"><a href="#cb22-262" aria-hidden="true" tabindex="-1"></a>four_communities <span class="op">=</span> fits[<span class="dv">2</span>]</span>
<span id="cb22-263"><a href="#cb22-263" aria-hidden="true" tabindex="-1"></a><span class="co"># print(three_communities)</span></span>
<span id="cb22-264"><a href="#cb22-264" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [</span>
<span id="cb22-265"><a href="#cb22-265" aria-hidden="true" tabindex="-1"></a>    (</span>
<span id="cb22-266"><a href="#cb22-266" aria-hidden="true" tabindex="-1"></a>        <span class="st">"plum"</span> <span class="cf">if</span> node <span class="kw">in</span> four_communities[<span class="dv">0</span>]</span>
<span id="cb22-267"><a href="#cb22-267" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="st">"lightgreen"</span> <span class="cf">if</span> node <span class="kw">in</span> four_communities[<span class="dv">1</span>]</span>
<span id="cb22-268"><a href="#cb22-268" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="st">"orange"</span> <span class="cf">if</span> node <span class="kw">in</span> four_communities[<span class="dv">2</span>]</span>
<span id="cb22-269"><a href="#cb22-269" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="st">"lightblue"</span></span>
<span id="cb22-270"><a href="#cb22-270" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb22-271"><a href="#cb22-271" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> node <span class="kw">in</span> G.nodes</span>
<span id="cb22-272"><a href="#cb22-272" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb22-273"><a href="#cb22-273" aria-hidden="true" tabindex="-1"></a><span class="co"># visualize the network</span></span>
<span id="cb22-274"><a href="#cb22-274" aria-hidden="true" tabindex="-1"></a>nx.draw(</span>
<span id="cb22-275"><a href="#cb22-275" aria-hidden="true" tabindex="-1"></a>    G,</span>
<span id="cb22-276"><a href="#cb22-276" aria-hidden="true" tabindex="-1"></a>    pos,</span>
<span id="cb22-277"><a href="#cb22-277" aria-hidden="true" tabindex="-1"></a>    with_labels<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb22-278"><a href="#cb22-278" aria-hidden="true" tabindex="-1"></a>    node_color<span class="op">=</span>colors,</span>
<span id="cb22-279"><a href="#cb22-279" aria-hidden="true" tabindex="-1"></a>    node_size<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb22-280"><a href="#cb22-280" aria-hidden="true" tabindex="-1"></a>    edge_color<span class="op">=</span><span class="st">"gray"</span>,</span>
<span id="cb22-281"><a href="#cb22-281" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb22-282"><a href="#cb22-282" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-283"><a href="#cb22-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-284"><a href="#cb22-284" aria-hidden="true" tabindex="-1"></a><span class="fu"># Community detection using Louvaine's algorithm</span></span>
<span id="cb22-285"><a href="#cb22-285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-286"><a href="#cb22-286" aria-hidden="true" tabindex="-1"></a>The Louvain community detection algorithm<span class="ot">[^3]</span> is a popular method for identifying communities in large networks. It is an iterative, modularity-based algorithm that optimizes the modularity of a partition of the network<span class="ot">[^4]</span>. Modularity is a measure of the density of links inside communities compared to links between communities.</span>
<span id="cb22-287"><a href="#cb22-287" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-288"><a href="#cb22-288" aria-hidden="true" tabindex="-1"></a><span class="ot">[^3]: </span>Blondel, V. D., Guillaume, J. L., Lambiotte, R., &amp; Lefebvre, E. (2008). Fast unfolding of communities in large networks. Journal of Statistical Mechanics: Theory and Experiment, 2008(10), P10008. doi:10.1088/1742-5468/2008/10/P10008</span>
<span id="cb22-289"><a href="#cb22-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-290"><a href="#cb22-290" aria-hidden="true" tabindex="-1"></a><span class="ot">[^4]: </span>Nicolas Dugué, Anthony Perez. Directed Louvain : maximizing modularity in directed networks. <span class="co">[</span><span class="ot">Research Report</span><span class="co">]</span> Université d’Orléans. 2015. hal-01231784. https://hal.archives-ouvertes.fr/hal-01231784</span>
<span id="cb22-291"><a href="#cb22-291" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-292"><a href="#cb22-292" aria-hidden="true" tabindex="-1"></a>The algorithm operates in two main phases that are repeated iteratively. In the first phase, each node is assigned to its own community. Then, for each node, the algorithm considers moving it to the community of each of its neighbors, choosing the move that results in the highest increase (or smallest decrease) in modularity. This process is repeated for all nodes until no further improvement can be achieved.</span>
<span id="cb22-293"><a href="#cb22-293" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-294"><a href="#cb22-294" aria-hidden="true" tabindex="-1"></a>In the second phase, the algorithm aggregates nodes belonging to the same community into a single node, creating a new, smaller network. Edges between the new nodes are weighted by the sum of the weights of the edges between the original nodes in the corresponding communities. The first phase is then reapplied to this new network.</span>
<span id="cb22-295"><a href="#cb22-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-296"><a href="#cb22-296" aria-hidden="true" tabindex="-1"></a>These two phases are repeated iteratively until the modularity no longer increases significantly. The result is a hierarchical decomposition of the network into communities, which can be represented at different levels of granularity. The Louvain algorithm is efficient and can handle large networks, making it widely used in various applications, including social network analysis, biology, and information retrieval.</span>
<span id="cb22-297"><a href="#cb22-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-298"><a href="#cb22-298" aria-hidden="true" tabindex="-1"></a>Let us consider an example of applying the Louvain algorithm to the Karate Club network. The <span class="in">`community`</span> module in <span class="in">`networkx`</span> provides an implementation of the Louvain algorithm, which we can use to detect communities in the network.</span>
<span id="cb22-299"><a href="#cb22-299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-302"><a href="#cb22-302" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb22-303"><a href="#cb22-303" aria-hidden="true" tabindex="-1"></a><span class="co"># Louvain algorithm fit</span></span>
<span id="cb22-304"><a href="#cb22-304" aria-hidden="true" tabindex="-1"></a>fit <span class="op">=</span> nx.community.louvain_communities(G)</span>
<span id="cb22-305"><a href="#cb22-305" aria-hidden="true" tabindex="-1"></a><span class="co"># retriece the communities</span></span>
<span id="cb22-306"><a href="#cb22-306" aria-hidden="true" tabindex="-1"></a>communities <span class="op">=</span> <span class="bu">tuple</span>(<span class="bu">sorted</span>(c) <span class="cf">for</span> c <span class="kw">in</span> fit)</span>
<span id="cb22-307"><a href="#cb22-307" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(communities)</span>
<span id="cb22-308"><a href="#cb22-308" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-309"><a href="#cb22-309" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-310"><a href="#cb22-310" aria-hidden="true" tabindex="-1"></a>The community structure solution that maximizes the modularity criterion comprisese the following communities: <span class="in">`0, 1, 2, 3, 7, 13, 17, 19, 21`</span> and <span class="in">`4, 5, 6, 10, 16`</span> and <span class="in">`8, 9, 11, 12, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33`</span>. The following @fig-karate-club-louvain-communities visualize the network with the identified communities.</span>
<span id="cb22-311"><a href="#cb22-311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-314"><a href="#cb22-314" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb22-315"><a href="#cb22-315" aria-hidden="true" tabindex="-1"></a><span class="co"># | fig-cap: Visualization of the Karate Club network with Louvain communities</span></span>
<span id="cb22-316"><a href="#cb22-316" aria-hidden="true" tabindex="-1"></a><span class="co"># | fig-cap-location: margin</span></span>
<span id="cb22-317"><a href="#cb22-317" aria-hidden="true" tabindex="-1"></a><span class="co"># | fig-width: 500</span></span>
<span id="cb22-318"><a href="#cb22-318" aria-hidden="true" tabindex="-1"></a><span class="co"># | label: fig-karate-club-louvain-communities</span></span>
<span id="cb22-319"><a href="#cb22-319" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [</span>
<span id="cb22-320"><a href="#cb22-320" aria-hidden="true" tabindex="-1"></a>    (</span>
<span id="cb22-321"><a href="#cb22-321" aria-hidden="true" tabindex="-1"></a>        <span class="st">"plum"</span> <span class="cf">if</span> node <span class="kw">in</span> communities[<span class="dv">0</span>]</span>
<span id="cb22-322"><a href="#cb22-322" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="st">"lightgreen"</span> <span class="cf">if</span> node <span class="kw">in</span> communities[<span class="dv">1</span>]</span>
<span id="cb22-323"><a href="#cb22-323" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="st">"lightblue"</span></span>
<span id="cb22-324"><a href="#cb22-324" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb22-325"><a href="#cb22-325" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> node <span class="kw">in</span> G.nodes</span>
<span id="cb22-326"><a href="#cb22-326" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb22-327"><a href="#cb22-327" aria-hidden="true" tabindex="-1"></a><span class="co"># visualize the network</span></span>
<span id="cb22-328"><a href="#cb22-328" aria-hidden="true" tabindex="-1"></a>nx.draw(</span>
<span id="cb22-329"><a href="#cb22-329" aria-hidden="true" tabindex="-1"></a>    G,</span>
<span id="cb22-330"><a href="#cb22-330" aria-hidden="true" tabindex="-1"></a>    pos,</span>
<span id="cb22-331"><a href="#cb22-331" aria-hidden="true" tabindex="-1"></a>    with_labels<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb22-332"><a href="#cb22-332" aria-hidden="true" tabindex="-1"></a>    node_color<span class="op">=</span>colors,</span>
<span id="cb22-333"><a href="#cb22-333" aria-hidden="true" tabindex="-1"></a>    node_size<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb22-334"><a href="#cb22-334" aria-hidden="true" tabindex="-1"></a>    edge_color<span class="op">=</span><span class="st">"gray"</span>,</span>
<span id="cb22-335"><a href="#cb22-335" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb22-336"><a href="#cb22-336" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-337"><a href="#cb22-337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-338"><a href="#cb22-338" aria-hidden="true" tabindex="-1"></a>The Louvain algorithm is not only capable to isolate the most plausible community structure in a network. It can also handle weighted networks. Let us consider the case of a weighted Karate Club network, where the edge weights represent the strength of the friendship between members (see @fig-karate-club-weighted). The following code snippet shows how to create a weighted version of the Karate Club network and apply the Louvain algorithm to detect communities.</span>
<span id="cb22-339"><a href="#cb22-339" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-342"><a href="#cb22-342" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb22-343"><a href="#cb22-343" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Visualization of the weighted Karate Club network</span></span>
<span id="cb22-344"><a href="#cb22-344" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-karate-club-weighted</span></span>
<span id="cb22-345"><a href="#cb22-345" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap-location: margin</span></span>
<span id="cb22-346"><a href="#cb22-346" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-width: 500</span></span>
<span id="cb22-347"><a href="#cb22-347" aria-hidden="true" tabindex="-1"></a><span class="co"># weighted Karate Club network</span></span>
<span id="cb22-348"><a href="#cb22-348" aria-hidden="true" tabindex="-1"></a>G_weighted <span class="op">=</span> nx.karate_club_graph()</span>
<span id="cb22-349"><a href="#cb22-349" aria-hidden="true" tabindex="-1"></a><span class="co"># assign random weights to the edges</span></span>
<span id="cb22-350"><a href="#cb22-350" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb22-351"><a href="#cb22-351" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> u, v <span class="kw">in</span> G_weighted.edges:</span>
<span id="cb22-352"><a href="#cb22-352" aria-hidden="true" tabindex="-1"></a>    G_weighted[u][v][<span class="st">"weight"</span>] <span class="op">=</span> np.random.random_integers(<span class="dv">1</span>, <span class="dv">10</span>)</span>
<span id="cb22-353"><a href="#cb22-353" aria-hidden="true" tabindex="-1"></a><span class="co"># visualize the weighted network</span></span>
<span id="cb22-354"><a href="#cb22-354" aria-hidden="true" tabindex="-1"></a>nx.draw(</span>
<span id="cb22-355"><a href="#cb22-355" aria-hidden="true" tabindex="-1"></a>    G_weighted,</span>
<span id="cb22-356"><a href="#cb22-356" aria-hidden="true" tabindex="-1"></a>    pos,</span>
<span id="cb22-357"><a href="#cb22-357" aria-hidden="true" tabindex="-1"></a>    with_labels<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb22-358"><a href="#cb22-358" aria-hidden="true" tabindex="-1"></a>    node_color<span class="op">=</span><span class="st">"lightgray"</span>,</span>
<span id="cb22-359"><a href="#cb22-359" aria-hidden="true" tabindex="-1"></a>    node_size<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb22-360"><a href="#cb22-360" aria-hidden="true" tabindex="-1"></a>    edge_color<span class="op">=</span>[G_weighted[u][v][<span class="st">"weight"</span>] <span class="cf">for</span> u, v <span class="kw">in</span> G_weighted.edges],</span>
<span id="cb22-361"><a href="#cb22-361" aria-hidden="true" tabindex="-1"></a>    edge_cmap<span class="op">=</span>plt.cm.Greens,</span>
<span id="cb22-362"><a href="#cb22-362" aria-hidden="true" tabindex="-1"></a>    edge_vmin<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb22-363"><a href="#cb22-363" aria-hidden="true" tabindex="-1"></a>    edge_vmax<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb22-364"><a href="#cb22-364" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb22-365"><a href="#cb22-365" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-366"><a href="#cb22-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-367"><a href="#cb22-367" aria-hidden="true" tabindex="-1"></a>Then, we fit the Louvain algorithm to the weighted network and visualize the communities --- see @fig-karate-club-louvain-communities-weighted.</span>
<span id="cb22-368"><a href="#cb22-368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-371"><a href="#cb22-371" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb22-372"><a href="#cb22-372" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Visualization of the Karate Club network with Louvain communities in the weighted network</span></span>
<span id="cb22-373"><a href="#cb22-373" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap-location: margin</span></span>
<span id="cb22-374"><a href="#cb22-374" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-width: 500</span></span>
<span id="cb22-375"><a href="#cb22-375" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-karate-club-louvain-communities-weighted</span></span>
<span id="cb22-376"><a href="#cb22-376" aria-hidden="true" tabindex="-1"></a><span class="co"># fit the Louvain algorithm to the weighted network</span></span>
<span id="cb22-377"><a href="#cb22-377" aria-hidden="true" tabindex="-1"></a>fit <span class="op">=</span> nx.community.louvain_communities(G_weighted, weight<span class="op">=</span><span class="st">"weight"</span>)</span>
<span id="cb22-378"><a href="#cb22-378" aria-hidden="true" tabindex="-1"></a><span class="co"># retrieve the communities</span></span>
<span id="cb22-379"><a href="#cb22-379" aria-hidden="true" tabindex="-1"></a>communities <span class="op">=</span> <span class="bu">tuple</span>(<span class="bu">sorted</span>(c) <span class="cf">for</span> c <span class="kw">in</span> fit)</span>
<span id="cb22-380"><a href="#cb22-380" aria-hidden="true" tabindex="-1"></a><span class="co"># visualize the network with the identified communities</span></span>
<span id="cb22-381"><a href="#cb22-381" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [</span>
<span id="cb22-382"><a href="#cb22-382" aria-hidden="true" tabindex="-1"></a>    (</span>
<span id="cb22-383"><a href="#cb22-383" aria-hidden="true" tabindex="-1"></a>        <span class="st">"plum"</span> <span class="cf">if</span> node <span class="kw">in</span> communities[<span class="dv">0</span>]</span>
<span id="cb22-384"><a href="#cb22-384" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="st">"lightgreen"</span> <span class="cf">if</span> node <span class="kw">in</span> communities[<span class="dv">1</span>]</span>
<span id="cb22-385"><a href="#cb22-385" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="st">"lightblue"</span></span>
<span id="cb22-386"><a href="#cb22-386" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb22-387"><a href="#cb22-387" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> node <span class="kw">in</span> G_weighted.nodes</span>
<span id="cb22-388"><a href="#cb22-388" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb22-389"><a href="#cb22-389" aria-hidden="true" tabindex="-1"></a><span class="co"># visualize the network</span></span>
<span id="cb22-390"><a href="#cb22-390" aria-hidden="true" tabindex="-1"></a>nx.draw(</span>
<span id="cb22-391"><a href="#cb22-391" aria-hidden="true" tabindex="-1"></a>    G_weighted,</span>
<span id="cb22-392"><a href="#cb22-392" aria-hidden="true" tabindex="-1"></a>    pos,</span>
<span id="cb22-393"><a href="#cb22-393" aria-hidden="true" tabindex="-1"></a>    with_labels<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb22-394"><a href="#cb22-394" aria-hidden="true" tabindex="-1"></a>    node_color<span class="op">=</span>colors,</span>
<span id="cb22-395"><a href="#cb22-395" aria-hidden="true" tabindex="-1"></a>    node_size<span class="op">=</span><span class="dv">300</span>,</span>
<span id="cb22-396"><a href="#cb22-396" aria-hidden="true" tabindex="-1"></a>    edge_color<span class="op">=</span>[G_weighted[u][v][<span class="st">"weight"</span>] <span class="cf">for</span> u, v <span class="kw">in</span> G_weighted.edges],</span>
<span id="cb22-397"><a href="#cb22-397" aria-hidden="true" tabindex="-1"></a>    edge_cmap<span class="op">=</span>plt.cm.Greens,</span>
<span id="cb22-398"><a href="#cb22-398" aria-hidden="true" tabindex="-1"></a>    edge_vmin<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb22-399"><a href="#cb22-399" aria-hidden="true" tabindex="-1"></a>    edge_vmax<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb22-400"><a href="#cb22-400" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb22-401"><a href="#cb22-401" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-402"><a href="#cb22-402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-403"><a href="#cb22-403" aria-hidden="true" tabindex="-1"></a>Considering the weighted network, the Louvain algorithm yields some notable results:</span>
<span id="cb22-404"><a href="#cb22-404" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-405"><a href="#cb22-405" aria-hidden="true" tabindex="-1"></a><span class="ss">+ </span>The strong ties between nodes <span class="in">`0`</span>, <span class="in">`4`</span>m, and <span class="in">`10`</span> make nodes <span class="in">`0`</span> and <span class="in">`4`</span> part of the same community, despite the redundant ties to nodes <span class="in">`5`</span>, <span class="in">`6`</span> and <span class="in">`15`</span> (compare @fig-karate-club-louvain-communities and @fig-karate-club-louvain-communities-weighted)</span>
<span id="cb22-406"><a href="#cb22-406" aria-hidden="true" tabindex="-1"></a><span class="ss">+ </span>Nodes located at the boarder of the communities are more likely to be assigned to the community with which they share the strongest ties. For example, node <span class="in">`9`</span> is assigned to the same community as node <span class="in">`30`</span>; node <span class="in">`19`</span> is assigned to to the same community as node <span class="in">`3`</span>.</span>
</code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>
{
  "hash": "7cb5af891b912aff180c5677c474932d",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Problem Set 2: Degree Centrality and Degree Distribution (Python)\"\nsubtitle: \"Week 2 - Network Analytics\"\ndate: \"today\"\nformat: html\njupyter: python3\n---\n\n## Overview\n\nIn this problem set, you will work with real-world network data from Wikipedia to compute degree centrality measures and analyze degree distributions using Python. This exercise will help you understand:\n\n- How to load and process directed network data with NetworkX\n- The difference between in-degree and out-degree centrality\n- How to compute and visualize degree distributions\n- What degree distributions reveal about network structure\n\n## Dataset: Wikipedia Vote Network\n\n**Description**: This network represents voting relationships among Wikipedia users during administrator elections from the site's inception through January 2008.\n\n**Network Properties**:\n\n- **Nodes**: 7,115 Wikipedia users\n- **Edges**: 103,689 directed edges\n- **Edge meaning**: A directed edge from user i to user j means that user i voted on user j\n- **Network type**: Directed, unweighted\n\n**Source**: [Stanford SNAP - Wikipedia Vote Network](https://snap.stanford.edu/data/wiki-Vote.html)\n\n## Task 1: Download and Load the Data\n\nFirst, download the dataset and load it into Python using NetworkX.\n\n::: {#5a3b61d7 .cell execution_count=1}\n``` {.python .cell-code code-fold=\"false\"}\nimport networkx as nx\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom urllib.request import urlretrieve\nimport gzip\nimport io\n\n# Download the dataset\nurl = \"https://snap.stanford.edu/data/wiki-Vote.txt.gz\"\nurlretrieve(url, \"wiki-Vote.txt.gz\")\n\n# Read the edge list (skip comment lines that start with #)\nedges = []\nwith gzip.open(\"wiki-Vote.txt.gz\", \"rt\") as f:\n    for line in f:\n        if not line.startswith(\"#\"):\n            from_node, to_node = map(int, line.strip().split())\n            edges.append((from_node, to_node))\n\n# Create a directed graph\nG = nx.DiGraph()\nG.add_edges_from(edges)\n\n# Basic network statistics\nprint(f\"Number of nodes: {G.number_of_nodes()}\")\nprint(f\"Number of edges: {G.number_of_edges()}\")\nprint(f\"Is directed: {nx.is_directed(G)}\")\n```\n:::\n\n\n::: {.callout-tip}\n## Understanding the Data Format\n\nThe wiki-Vote.txt file contains lines starting with `#` (comments) followed by an edge list where each line represents a directed edge: `FromNodeId ToNodeId`\n:::\n\n---\n\n## Task 2: Compute In-Degree and Out-Degree\n\nCalculate the in-degree and out-degree for all nodes in the network.\n\n**Questions**:\n\n1. What is the maximum in-degree? What does this represent in the context of Wikipedia voting?\n2. What is the maximum out-degree? What does this represent?\n3. How many nodes have in-degree of 0? What does this mean?\n4. How many nodes have out-degree of 0? What does this mean?\n\n::: {#0171990b .cell execution_count=2}\n``` {.python .cell-code code-fold=\"false\"}\n# Compute in-degree and out-degree\nin_degrees = dict(G.in_degree())\nout_degrees = dict(G.out_degree())\n\n# Convert to arrays for easier analysis\nin_deg_values = np.array(list(in_degrees.values()))\nout_deg_values = np.array(list(out_degrees.values()))\n\n# Summary statistics\nprint(\"In-Degree Statistics:\")\nprint(f\"  Max: {np.max(in_deg_values)}\")\nprint(f\"  Mean: {np.mean(in_deg_values):.2f}\")\nprint(f\"  Median: {np.median(in_deg_values)}\")\nprint(f\"  Nodes with in-degree = 0: {np.sum(in_deg_values == 0)}\\n\")\n\nprint(\"Out-Degree Statistics:\")\nprint(f\"  Max: {np.max(out_deg_values)}\")\nprint(f\"  Mean: {np.mean(out_deg_values):.2f}\")\nprint(f\"  Median: {np.median(out_deg_values)}\")\nprint(f\"  Nodes with out-degree = 0: {np.sum(out_deg_values == 0)}\")\n\n# Find the most \"voted-on\" user\nmost_voted_user = max(in_degrees, key=in_degrees.get)\nprint(f\"\\nMost voted-on user: Node {most_voted_user} with in-degree = {in_degrees[most_voted_user]}\")\n\n# Find the most active voter\nmost_active_voter = max(out_degrees, key=out_degrees.get)\nprint(f\"Most active voter: Node {most_active_voter} with out-degree = {out_degrees[most_active_voter]}\")\n```\n:::\n\n\n::: {.callout-tip}\n## Interpreting Degree Centrality in Directed Networks\n\n- **In-degree**: Number of votes received (popularity, endorsement)\n- **Out-degree**: Number of votes cast (activity, participation)\n:::\n\n---\n\n## Task 3: Analyze the Top 10 Users\n\nIdentify and compare the top 10 users by in-degree and out-degree.\n\n::: {#e77338f0 .cell execution_count=3}\n``` {.python .cell-code code-fold=\"false\"}\n# Create a DataFrame with degree measures\ndegree_df = pd.DataFrame({\n    'node': list(G.nodes()),\n    'in_degree': [in_degrees[node] for node in G.nodes()],\n    'out_degree': [out_degrees[node] for node in G.nodes()]\n})\ndegree_df['total_degree'] = degree_df['in_degree'] + degree_df['out_degree']\n\n# Top 10 by in-degree (most voted-on)\ntop_in = degree_df.nlargest(10, 'in_degree')\nprint(\"Top 10 Users by In-Degree (Most Votes Received):\")\nprint(top_in)\n\n# Top 10 by out-degree (most active voters)\ntop_out = degree_df.nlargest(10, 'out_degree')\nprint(\"\\nTop 10 Users by Out-Degree (Most Votes Cast):\")\nprint(top_out)\n\n# Are the top users in both categories the same?\noverlap = len(set(top_in['node']) & set(top_out['node']))\nprint(f\"\\nOverlap between top in-degree and top out-degree users: {overlap} out of 10\")\n```\n:::\n\n\n**Question**: Do highly endorsed users (high in-degree) also tend to be active voters (high out-degree)? What does this tell you about participation patterns?\n\n---\n\n## Task 4: Compute Degree Distribution\n\nCalculate the degree distribution for both in-degree and out-degree.\n\n::: {#5d8dcdcb .cell execution_count=4}\n``` {.python .cell-code code-fold=\"false\"}\n# Compute degree distributions\nin_degree_counts = pd.Series(in_deg_values).value_counts().sort_index()\nout_degree_counts = pd.Series(out_deg_values).value_counts().sort_index()\n\n# Convert to DataFrames for plotting\nin_deg_df = pd.DataFrame({\n    'degree': in_degree_counts.index,\n    'frequency': in_degree_counts.values,\n    'type': 'In-Degree'\n})\n\nout_deg_df = pd.DataFrame({\n    'degree': out_degree_counts.index,\n    'frequency': out_degree_counts.values,\n    'type': 'Out-Degree'\n})\n\n# Combine for comparison\ncombined_deg_df = pd.concat([in_deg_df, out_deg_df], ignore_index=True)\n\n# View the first few rows\nprint(\"In-Degree Distribution (first 10 rows):\")\nprint(in_deg_df.head(10))\nprint(\"\\nOut-Degree Distribution (first 10 rows):\")\nprint(out_deg_df.head(10))\n```\n:::\n\n\n---\n\n## Task 5: Plot Degree Distribution\n\nCreate visualizations of the degree distributions using both linear and log-log scales.\n\n### Linear Scale Plot\n\n::: {#d048655a .cell fig-height='6' fig-width='10' execution_count=5}\n``` {.python .cell-code code-fold=\"false\"}\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Set style\nplt.style.use('default')\nsns.set_palette([\"#c41c85\", \"#50C878\"])\n\n# Plot on linear scale\nfig, ax = plt.subplots(figsize=(10, 6))\n\nfor deg_type in ['In-Degree', 'Out-Degree']:\n    data = combined_deg_df[combined_deg_df['type'] == deg_type]\n    color = \"#c41c85\" if deg_type == \"In-Degree\" else \"#50C878\"\n    ax.plot(data['degree'], data['frequency'], 'o-', alpha=0.6, \n            label=deg_type, color=color, markersize=4, linewidth=1)\n\nax.set_xlabel('Degree (k)')\nax.set_ylabel('Frequency (Number of Nodes)')\nax.set_title('Degree Distribution - Wikipedia Vote Network\\nLinear scale', \n             fontsize=14, fontweight='bold')\nax.legend()\nax.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n### Log-Log Scale Plot\n\n::: {#2b2fb1a9 .cell fig-height='6' fig-width='10' execution_count=6}\n``` {.python .cell-code code-fold=\"false\"}\n# Plot on log-log scale\nfig, ax = plt.subplots(figsize=(10, 6))\n\nfor deg_type in ['In-Degree', 'Out-Degree']:\n    data = combined_deg_df[combined_deg_df['type'] == deg_type]\n    # Filter out zero values for log scale\n    data_filtered = data[data['degree'] > 0]\n    color = \"#c41c85\" if deg_type == \"In-Degree\" else \"#50C878\"\n    ax.loglog(data_filtered['degree'], data_filtered['frequency'], 'o-', \n              alpha=0.6, label=deg_type, color=color, markersize=4, linewidth=1)\n\nax.set_xlabel('Degree (k) [log scale]')\nax.set_ylabel('Frequency [log scale]')\nax.set_title('Degree Distribution - Wikipedia Vote Network\\nLog-log scale', \n             fontsize=14, fontweight='bold')\nax.legend()\nax.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n**Questions**:\n\n1. What shape does the degree distribution follow on the log-log scale?\n2. Does the distribution appear to follow a power law? If so, what does this indicate?\n3. How do the in-degree and out-degree distributions compare?\n4. What does the degree distribution tell you about the structure of Wikipedia's voting network?\n\n::: {.callout-tip}\n## Interpreting Degree Distributions\n\n- **Linear appearance on log-log plot**: Suggests a power-law (scale-free) distribution\n- **Power-law networks**: Few nodes with very high degree (hubs), many nodes with low degree\n- **Implications**: Highly skewed participation; a small number of elite users receive most votes\n:::\n\n---\n\n## Task 6: Compute Complementary Cumulative Distribution Function (CCDF)\n\nThe CCDF is often more robust than the degree distribution for identifying power laws.\n\n::: {#eabf3bbd .cell fig-height='6' fig-width='10' execution_count=7}\n``` {.python .cell-code code-fold=\"false\"}\ndef compute_ccdf(degrees):\n    \"\"\"Compute complementary cumulative distribution function\"\"\"\n    degree_counts = pd.Series(degrees).value_counts().sort_index()\n    total_nodes = len(degrees)\n    \n    ccdf_data = []\n    for degree in degree_counts.index:\n        # P(X >= k) = number of nodes with degree >= k / total nodes\n        prob = np.sum([degree_counts[d] for d in degree_counts.index if d >= degree]) / total_nodes\n        ccdf_data.append({'degree': degree, 'ccdf': prob})\n    \n    return pd.DataFrame(ccdf_data)\n\n# Compute CCDF for in-degree and out-degree\nin_ccdf = compute_ccdf(in_deg_values)\nin_ccdf['type'] = 'In-Degree'\n\nout_ccdf = compute_ccdf(out_deg_values)\nout_ccdf['type'] = 'Out-Degree'\n\nccdf_combined = pd.concat([in_ccdf, out_ccdf], ignore_index=True)\n\n# Plot CCDF on log-log scale\nfig, ax = plt.subplots(figsize=(10, 6))\n\nfor deg_type in ['In-Degree', 'Out-Degree']:\n    data = ccdf_combined[ccdf_combined['type'] == deg_type]\n    # Filter out zero values for log scale\n    data_filtered = data[(data['degree'] > 0) & (data['ccdf'] > 0)]\n    color = \"#c41c85\" if deg_type == \"In-Degree\" else \"#50C878\"\n    ax.loglog(data_filtered['degree'], data_filtered['ccdf'], 'o-', \n              alpha=0.6, label=deg_type, color=color, markersize=4, linewidth=1)\n\nax.set_xlabel('Degree (k) [log scale]')\nax.set_ylabel('P(X e k) [log scale]')\nax.set_title('Complementary Cumulative Distribution Function (CCDF)\\nWikipedia Vote Network - Log-log scale', \n             fontsize=14, fontweight='bold')\nax.legend()\nax.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n---\n\n## Reflection Questions\n\nAfter completing all tasks, answer the following:\n\n1. **Inequality in participation**: What fraction of users received more than 100 votes? What fraction cast more than 100 votes?\n\n2. **Network interpretation**: Based on the degree distributions, how would you characterize the Wikipedia voting system? Is it egalitarian or hierarchical?\n\n3. **Power-law hypothesis**: Do the log-log plots suggest a power-law distribution? What would be the next steps to formally test this hypothesis?\n\n4. **Directed vs undirected**: How would your analysis differ if this were an undirected network?\n\n5. **Practical implications**: What does the degree distribution suggest about which users have influence in the Wikipedia administrator election process?\n\n---\n\n## Solutions and Hints\n\n::: {.callout-note collapse=\"true\"}\n## Click to reveal hints and expected results\n\n### Expected Statistics:\n\nBased on the SNAP documentation:\n\n- **Nodes**: 7,115\n- **Edges**: 103,689\n- **Average in-degree** H 14.57 (total edges / nodes)\n- **Average out-degree** H 14.57 (same for directed networks)\n\n### Degree Distribution Characteristics:\n\nBoth in-degree and out-degree distributions should show:\n\n- **Heavy-tailed distribution**: Most nodes have low degree, few have very high degree\n- **Approximate power-law**: Linear relationship on log-log plot\n- **High inequality**: Small fraction of users account for large fraction of votes\n\n### Interpretation:\n\n**High in-degree nodes**: Highly endorsed candidates, likely successful administrators or trusted community members\n\n**High out-degree nodes**: Very active voters, engaged community participants\n\n**Low degree nodes**: Casual users, single-election participants, or new users\n\n### Code Snippet for Computing Inequality:\n\n```python\n# What fraction of users received > 100 votes?\nhigh_in = np.sum(in_deg_values > 100) / len(in_deg_values)\nprint(f\"Fraction with in-degree > 100: {high_in:.4f}\")\n\n# What fraction cast > 100 votes?\nhigh_out = np.sum(out_deg_values > 100) / len(out_deg_values)\nprint(f\"Fraction with out-degree > 100: {high_out:.4f}\")\n```\n\n### Power-Law Testing:\n\nTo formally test for power-law distribution, you could use the `powerlaw` package:\n\n```python\nimport powerlaw\n\n# Fit power-law to in-degree (exclude zeros)\nin_deg_nonzero = in_deg_values[in_deg_values > 0]\nfit = powerlaw.Fit(in_deg_nonzero)\n\nprint(f\"Power-law exponent (alpha): {fit.power_law.alpha:.3f}\")\nprint(f\"xmin: {fit.power_law.xmin}\")\n\n# Test power-law vs alternatives\nR, p = fit.distribution_compare('power_law', 'exponential')\nprint(f\"Power-law vs exponential R: {R:.3f}, p-value: {p:.3f}\")\n```\n\n:::\n\n---\n\n## Additional Challenges\n\n::: {.callout-warning}\n## Advanced Questions\n\n1. **Correlation analysis**: Calculate the correlation between in-degree and out-degree. Are they correlated? What does this mean?\n\n2. **Degree centrality vs other measures**: Compute betweenness centrality for the top 20 nodes by in-degree. Are high-degree nodes also high in betweenness?\n\n3. **Subgraph analysis**: Extract the subgraph containing only nodes with in-degree > 50. What is the density of this subgraph?\n\n4. **Temporal analysis**: The dataset includes a timestamp. How has the degree distribution evolved over time?\n\n5. **Network resilience**: What would happen to the network's connectivity if you removed the top 1% of nodes by in-degree? (Hint: compute the size of the largest connected component before and after removal)\n\n:::\n\n---\n\n## Submission Guidelines\n\nYour submission should include:\n\n1. **Python script or Jupyter notebook** with all code and outputs\n2. **Visualizations** of degree distributions (linear and log-log scales)\n3. **Written answers** to all reflection questions (200-400 words total)\n4. **Interpretation** of what the degree distribution reveals about Wikipedia's voting network\n\n**File naming**: `week2_perform2_[YourName].ipynb` or `.py`\n\n**Due date**: Check the course schedule\n\n",
    "supporting": [
      "perform_2_files"
    ],
    "filters": [],
    "includes": {}
  }
}
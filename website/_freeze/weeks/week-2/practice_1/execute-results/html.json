{
  "hash": "02b8142fb436f9079927500f0f2930dd",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Practice: Ingesting Network Data and Computing Degree\"\nsubtitle: \"Week 2 - Network Analytics\"\n---\n\n## Learning Objectives\n\nIn this tutorial, you will learn how to:\n\n1. Download and load real-world network data\n2. Create a network (graph) object in R using `igraph`\n3. Compute basic network statistics (node count, edge count)\n4. Calculate node degree centrality\n5. Visualize degree distributions\n\n## Dataset: Email Communication Network\n\nWe will use the **email-Eu-core** dataset from the Stanford Network Analysis Project (SNAP).\n\n**Description**: This network represents email communications within a large European research institution.\n\n**Network Properties**:\n\n- **Nodes**: 1,005 individuals (members of the institution)\n- **Edges**: 25,571 directed edges\n- **Edge meaning**: If person u sent person v at least one email, there is a directed edge from u to v\n- **Network type**: Directed\n\n**Source**: [SNAP - Email-Eu-core Network](https://snap.stanford.edu/data/email-Eu-core.html)\n\n---\n\n## Step 1: Setup and Load Required Libraries\n\nFirst, we need to load the R packages we will use for network analysis and visualization.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load required libraries\nlibrary(igraph)      # Network analysis\nlibrary(ggplot2)     # Data visualization\nlibrary(dplyr)       # Data manipulation\nlibrary(knitr)       # Table formatting\n\n# Check if packages are loaded\ncat(\"All packages loaded successfully!\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAll packages loaded successfully!\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip}\n## Installing Packages\n\nIf you do not have these packages installed, run:\n```r\ninstall.packages(c(\"igraph\", \"ggplot2\", \"dplyr\", \"knitr\"))\n```\n:::\n\n---\n\n## Step 2: Download the Dataset\n\nLet us download the email network data from SNAP.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a directory for data if it does not exist\nif (!dir.exists(\"data\")) {\n  dir.create(\"data\")\n}\n\n# Download the dataset\nurl <- \"https://snap.stanford.edu/data/email-Eu-core.txt.gz\"\ndestfile <- \"data/email-Eu-core.txt.gz\"\n\n# Download if file does not already exist\nif (!file.exists(destfile)) {\n  download.file(url, destfile)\n  cat(\"Dataset downloaded successfully!\\n\")\n} else {\n  cat(\"Dataset already exists. Skipping download.\\n\")\n}\n```\n:::\n\n\n::: {.callout-note}\n## File Format\n\nThe dataset is in `.txt.gz` format (compressed text file). R can read this directly without manual decompression!\n:::\n\n---\n\n## Step 3: Load the Network Data\n\nNow we will read the edge list and examine its structure.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read the edge list\n# The file contains two columns: FromNodeId ToNodeId\nedge_data <- read.table(\"data/email-Eu-core.txt.gz\",\n                        header = FALSE,\n                        col.names = c(\"from\", \"to\"))\n\n# View the first few rows\ncat(\"First 10 edges in the network:\\n\")\nhead(edge_data, 10)\n\n# Check the structure\ncat(\"\\nDataset dimensions:\\n\")\ncat(\"Number of edges:\", nrow(edge_data), \"\\n\")\ncat(\"Number of columns:\", ncol(edge_data), \"\\n\")\n```\n:::\n\n\n**Expected Output:**\n```\nFirst 10 edges in the network:\n   from  to\n1     0   1\n2     0   2\n3     0   3\n4     0   4\n5     0   5\n...\n\nDataset dimensions:\nNumber of edges: 25571\nNumber of columns: 2\n```\n\n::: {.callout-tip}\n## Understanding Edge Lists\n\nAn **edge list** is the simplest way to represent a network:\n- Each row represents one edge (connection)\n- First column: source node (sender)\n- Second column: target node (receiver)\n:::\n\n---\n\n## Step 4: Create a Network Object\n\nWe will use `igraph` to create a graph object from the edge list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a directed graph from the edge list\ng <- graph_from_data_frame(edge_data, directed = TRUE)\n\n# Display basic information\ncat(\"Network created successfully!\\n\\n\")\ncat(\"Network Summary:\\n\")\ncat(\"  Number of nodes:\", vcount(g), \"\\n\")\ncat(\"  Number of edges:\", ecount(g), \"\\n\")\ncat(\"  Is directed:\", is_directed(g), \"\\n\")\ncat(\"  Is weighted:\", is_weighted(g), \"\\n\")\n```\n:::\n\n\n**Expected Output:**\n```\nNetwork created successfully!\n\nNetwork Summary:\n  Number of nodes: 1005\n  Number of edges: 25571\n  Is directed: TRUE\n  Is weighted: FALSE\n```\n\n::: {.callout-important}\n## Directed vs Undirected\n\nThis network is **directed** because emails have a sender and receiver. The direction matters!\n\n- Edge A -> B: Person A sent email to Person B\n- This is different from B -> A\n:::\n\n---\n\n## Step 5: Compute Node Degree\n\nNow let us calculate degree centrality for all nodes in the network.\n\n### In-Degree and Out-Degree\n\nIn a directed network, each node has two types of degree:\n\n- **In-degree**: Number of incoming edges (emails received)\n- **Out-degree**: Number of outgoing edges (emails sent)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute in-degree (emails received)\nin_degree <- degree(g, mode = \"in\")\n\n# Compute out-degree (emails sent)\nout_degree <- degree(g, mode = \"out\")\n\n# Compute total degree (in + out)\ntotal_degree <- degree(g, mode = \"all\")\n\n# View summary statistics\ncat(\"In-Degree Statistics:\\n\")\ncat(\"  Min:\", min(in_degree), \"\\n\")\ncat(\"  Max:\", max(in_degree), \"\\n\")\ncat(\"  Mean:\", round(mean(in_degree), 2), \"\\n\")\ncat(\"  Median:\", median(in_degree), \"\\n\\n\")\n\ncat(\"Out-Degree Statistics:\\n\")\ncat(\"  Min:\", min(out_degree), \"\\n\")\ncat(\"  Max:\", max(out_degree), \"\\n\")\ncat(\"  Mean:\", round(mean(out_degree), 2), \"\\n\")\ncat(\"  Median:\", median(out_degree), \"\\n\")\n```\n:::\n\n\n**Expected Output:**\n```\nIn-Degree Statistics:\n  Min: 0\n  Max: 345\n  Mean: 25.45\n  Median: 12\n\nOut-Degree Statistics:\n  Min: 0\n  Max: 345\n  Mean: 25.45\n  Median: 12\n```\n\n---\n\n## Step 6: Identify High-Degree Nodes\n\nLet us find the most active email senders and receivers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a data frame with degree measures\ndegree_df <- data.frame(\n  node_id = V(g)$name,\n  in_degree = in_degree,\n  out_degree = out_degree,\n  total_degree = total_degree\n)\n\n# Find top 10 nodes by in-degree (most emails received)\ntop_in <- degree_df %>%\n  arrange(desc(in_degree)) %>%\n  head(10)\n\ncat(\"Top 10 Email Recipients (Highest In-Degree):\\n\")\nprint(top_in)\n\n# Find top 10 nodes by out-degree (most emails sent)\ntop_out <- degree_df %>%\n  arrange(desc(out_degree)) %>%\n  head(10)\n\ncat(\"\\nTop 10 Email Senders (Highest Out-Degree):\\n\")\nprint(top_out)\n```\n:::\n\n\n::: {.callout-tip}\n## Interpreting Degree Centrality\n\n- **High in-degree**: Popular or important person; receives many emails\n- **High out-degree**: Very active communicator; sends many emails\n- **High total degree**: Highly connected; both sends and receives many emails\n:::\n\n---\n\n## Step 7: Create a Summary Table\n\nLet us create a formatted table showing degree statistics.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Summary statistics table\ndegree_summary <- data.frame(\n  Metric = c(\"In-Degree\", \"Out-Degree\", \"Total Degree\"),\n  Minimum = c(min(in_degree), min(out_degree), min(total_degree)),\n  Maximum = c(max(in_degree), max(out_degree), max(total_degree)),\n  Mean = round(c(mean(in_degree), mean(out_degree), mean(total_degree)), 2),\n  Median = c(median(in_degree), median(out_degree), median(total_degree))\n)\n\n# Display as formatted table\nkable(degree_summary,\n      caption = \"Degree Centrality Summary Statistics\",\n      align = \"c\")\n```\n:::\n\n\n---\n\n## Step 8: Visualize Degree Distribution\n\nLet us create a histogram to visualize the distribution of degrees.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Create histogram of in-degree\nggplot(degree_df, aes(x = in_degree)) +\n  geom_histogram(bins = 50, fill = \"#c41c85\", alpha = 0.7, color = \"white\") +\n  labs(\n    title = \"Distribution of In-Degree (Emails Received)\",\n    x = \"In-Degree (Number of emails received)\",\n    y = \"Frequency (Number of nodes)\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\", size = 14),\n    axis.title = element_text(size = 12)\n  )\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Create histogram of out-degree\nggplot(degree_df, aes(x = out_degree)) +\n  geom_histogram(bins = 50, fill = \"#50C878\", alpha = 0.7, color = \"white\") +\n  labs(\n    title = \"Distribution of Out-Degree (Emails Sent)\",\n    x = \"Out-Degree (Number of emails sent)\",\n    y = \"Frequency (Number of nodes)\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\", size = 14),\n    axis.title = element_text(size = 12)\n  )\n```\n:::\n\n\n---\n\n## Step 9: Compare In-Degree and Out-Degree\n\nAre people who receive many emails also sending many emails? Let us create a scatter plot to find out.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Scatter plot of in-degree vs out-degree\nggplot(degree_df, aes(x = out_degree, y = in_degree)) +\n  geom_point(alpha = 0.5, color = \"#c41c85\", size = 2) +\n  geom_abline(slope = 1, intercept = 0, linetype = \"dashed\", color = \"gray50\") +\n  labs(\n    title = \"In-Degree vs Out-Degree\",\n    subtitle = \"Diagonal line shows where in-degree = out-degree\",\n    x = \"Out-Degree (Emails Sent)\",\n    y = \"In-Degree (Emails Received)\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\", size = 14),\n    axis.title = element_text(size = 12)\n  )\n\n# Calculate correlation\ncorrelation <- cor(degree_df$in_degree, degree_df$out_degree)\ncat(\"\\nCorrelation between in-degree and out-degree:\", round(correlation, 3), \"\\n\")\n```\n:::\n\n\n::: {.callout-note}\n## Interpreting the Scatter Plot\n\n- **Points on the diagonal line**: People who send and receive equal numbers of emails\n- **Points above the line**: Receive more emails than they send\n- **Points below the line**: Send more emails than they receive\n- **Correlation coefficient**: Measures how strongly in-degree and out-degree are related (ranges from -1 to 1)\n:::\n\n---\n\n## Step 10: Identify Degree Categories\n\nLet us categorize nodes by their communication patterns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate percentiles\nin_75th <- quantile(in_degree, 0.75)\nout_75th <- quantile(out_degree, 0.75)\n\n# Categorize nodes\ndegree_df <- degree_df %>%\n  mutate(\n    category = case_when(\n      in_degree > in_75th & out_degree > out_75th ~ \"Active Communicators\",\n      in_degree > in_75th & out_degree <= out_75th ~ \"Email Receivers\",\n      in_degree <= in_75th & out_degree > out_75th ~ \"Email Senders\",\n      TRUE ~ \"Low Activity\"\n    )\n  )\n\n# Count nodes in each category\ncategory_counts <- degree_df %>%\n  group_by(category) %>%\n  summarise(count = n(), .groups = \"drop\") %>%\n  arrange(desc(count))\n\ncat(\"Node Categories:\\n\")\nprint(category_counts)\n\n# Calculate percentages\ncategory_counts <- category_counts %>%\n  mutate(percentage = round(count / sum(count) * 100, 1))\n\nkable(category_counts,\n      caption = \"Distribution of Communication Patterns\",\n      col.names = c(\"Category\", \"Count\", \"Percentage (%)\"),\n      align = \"c\")\n```\n:::\n\n\n---\n\n## Complete Code Example\n\nHere is the complete code you can run all at once:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Click to see complete code\"}\n# Load libraries\nlibrary(igraph)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(knitr)\n\n# Download data\nif (!dir.exists(\"data\")) dir.create(\"data\")\nurl <- \"https://snap.stanford.edu/data/email-Eu-core.txt.gz\"\ndestfile <- \"data/email-Eu-core.txt.gz\"\nif (!file.exists(destfile)) download.file(url, destfile)\n\n# Load network\nedge_data <- read.table(destfile, header = FALSE, col.names = c(\"from\", \"to\"))\ng <- graph_from_data_frame(edge_data, directed = TRUE)\n\n# Compute degree\nin_degree <- degree(g, mode = \"in\")\nout_degree <- degree(g, mode = \"out\")\ntotal_degree <- degree(g, mode = \"all\")\n\n# Create summary data frame\ndegree_df <- data.frame(\n  node_id = V(g)$name,\n  in_degree = in_degree,\n  out_degree = out_degree,\n  total_degree = total_degree\n)\n\n# Print summary\ncat(\"Network Summary:\\n\")\ncat(\"  Nodes:\", vcount(g), \"\\n\")\ncat(\"  Edges:\", ecount(g), \"\\n\")\ncat(\"  Average in-degree:\", round(mean(in_degree), 2), \"\\n\")\ncat(\"  Average out-degree:\", round(mean(out_degree), 2), \"\\n\")\n\n# Top nodes\ncat(\"\\nTop 5 by In-Degree:\\n\")\nprint(head(degree_df %>% arrange(desc(in_degree)), 5))\n\ncat(\"\\nTop 5 by Out-Degree:\\n\")\nprint(head(degree_df %>% arrange(desc(out_degree)), 5))\n\n# Visualize\nggplot(degree_df, aes(x = in_degree, y = out_degree)) +\n  geom_point(alpha = 0.5, color = \"#c41c85\") +\n  geom_abline(slope = 1, intercept = 0, linetype = \"dashed\") +\n  labs(title = \"In-Degree vs Out-Degree\",\n       x = \"In-Degree\", y = \"Out-Degree\") +\n  theme_minimal()\n```\n:::\n\n\n---\n\n## Practice Questions\n\n::: {.callout-warning}\n## Try It Yourself\n\n1. **Degree Distribution**: What percentage of nodes have in-degree greater than 50?\n\n2. **Network Density**: Calculate the network density. Is this a sparse or dense network?\n\n3. **Isolates**: How many nodes have total degree of 0? What might this represent?\n\n4. **Asymmetry**: Identify nodes where the difference between in-degree and out-degree is greater than 100. What does this tell you about their communication pattern?\n\n5. **Quartiles**: What is the in-degree at the 25th, 50th, and 75th percentiles?\n\n**Bonus Challenge**: Create a function that takes a node ID and returns its degree rank (1st, 2nd, 3rd, etc.) for both in-degree and out-degree.\n\n:::\n\n---\n\n## Key Takeaways\n\n::: {.callout-important}\n## Summary\n\n1. **Loading network data**: Edge lists are simple and common format for network data\n2. **Graph creation**: `graph_from_data_frame()` converts edge lists to network objects\n3. **Degree centrality**: Measures how connected each node is\n   - In-degree: incoming connections\n   - Out-degree: outgoing connections\n4. **Degree distribution**: Often follows a power-law (many nodes with low degree, few with high degree)\n5. **Correlation analysis**: Helps understand relationship between different centrality measures\n\n:::\n\n---\n\n## Next Steps\n\nNow that you can ingest network data and compute basic centrality measures, you are ready to:\n\n1. Explore other centrality measures (betweenness, closeness, eigenvector)\n2. Analyze community structure in networks\n3. Compare multiple networks\n4. Work with larger and more complex datasets\n\nCheck out [Problem Set 1](perform_1.qmd) to apply these skills to the Wikipedia Vote Network!\n\n---\n\n## Additional Resources\n\n- [igraph R package documentation](https://igraph.org/r/)\n- [SNAP datasets](https://snap.stanford.edu/data/)\n- [Network Science book by Barabasi](http://networksciencebook.com/)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
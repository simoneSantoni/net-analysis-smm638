{
  "hash": "bfed1b5ec99ac745d0cdb1615d90b964",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Community Detection in Python\"\nsubtitle: \"Exploring communities with NetworkX\"\nformat:\n  html:\n    code-fold: false\n    toc: true\n    toc-depth: 3\n    number-sections: true\njupyter: python3\nexecute:\n  warning: false\n  message: false\n---\n\n# Introduction\n\nThis tutorial demonstrates how to detect and analyze communities in networks using **Python** and **NetworkX**. We'll implement several community detection algorithms, compare their results, and visualize the detected communities.\n\n## Learning Objectives\n\nBy the end of this tutorial, you will be able to:\n\n- Load and explore network data in Python using NetworkX\n- Apply multiple community detection algorithms\n- Compute and interpret modularity\n- Compare community partitions across methods\n- Visualize community structure\n\n## Setup\n\n::: {#setup .cell execution_count=1}\n``` {.python .cell-code}\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\nfrom networkx.algorithms import community as nx_comm\n\n# Optional: Louvain community detection if installed\ntry:\n    import community as community_louvain\n    HAVE_LOUVAIN = True\nexcept ImportError:\n    HAVE_LOUVAIN = False\n\nnp.random.seed(42)\n```\n:::\n\n\n# Example 1: Zachary's Karate Club Network\n\n## Loading the Network\n\n::: {#load-karate .cell execution_count=2}\n``` {.python .cell-code}\nG = nx.karate_club_graph()\n\nprint(f\"Number of nodes: {G.number_of_nodes()}\")\nprint(f\"Number of edges: {G.number_of_edges()}\")\nprint(f\"Average clustering: {nx.average_clustering(G):.3f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of nodes: 34\nNumber of edges: 78\nAverage clustering: 0.571\n```\n:::\n:::\n\n\n## Visualizing the Original Network\n\n::: {#cell-viz-original .cell fig-height='6' fig-width='8' execution_count=3}\n``` {.python .cell-code}\npos = nx.spring_layout(G, seed=42)\n\nplt.figure(figsize=(8, 6))\nnx.draw_networkx(\n    G,\n    pos=pos,\n    node_size=300,\n    node_color=\"lightblue\",\n    edge_color=\"lightgray\",\n    with_labels=True,\n    font_size=8,\n)\nplt.title(\"Zachary's Karate Club Network\")\nplt.axis(\"off\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](practice_2_files/figure-html/viz-original-output-1.png){#viz-original width=614 height=483}\n:::\n:::\n\n\n# Community Detection Algorithms\n\nWe'll apply several algorithms and compare their results.\n\nHelper function to convert sets of communities into a membership vector and compute modularity.\n\n::: {#helpers .cell execution_count=4}\n``` {.python .cell-code}\nfrom itertools import count\n\n\ndef partition_to_membership(G, communities):\n    \"\"\"Convert iterable of sets to dict node -> community_id.\"\"\"\n    membership = {}\n    for cid, comm in enumerate(communities):\n        for node in comm:\n            membership[node] = cid\n    return membership\n\n\ndef print_partition_stats(G, communities, name):\n    modularity = nx_comm.modularity(G, communities)\n    sizes = [len(c) for c in communities]\n    print(f\"=== {name} ===\")\n    print(f\"Number of communities: {len(communities)}\")\n    print(f\"Community sizes: {sizes}\")\n    print(f\"Modularity: {modularity:.3f}\\n\")\n    return modularity\n```\n:::\n\n\n## Method 1: Greedy Modularity (Clauset-Newman-Moore)\n\n::: {#greedy .cell execution_count=5}\n``` {.python .cell-code}\ngreedy_comms = list(nx_comm.greedy_modularity_communities(G))\nmod_greedy = print_partition_stats(G, greedy_comms, \"Greedy Modularity\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n=== Greedy Modularity ===\nNumber of communities: 3\nCommunity sizes: [17, 9, 8]\nModularity: 0.411\n\n```\n:::\n:::\n\n\n### Visualization\n\n::: {#cell-viz-greedy .cell fig-height='6' fig-width='8' execution_count=6}\n``` {.python .cell-code}\nmembership_greedy = partition_to_membership(G, greedy_comms)\n\n# Assign colors by community\nunique_comms = sorted(set(membership_greedy.values()))\ncolor_map = plt.cm.get_cmap(\"tab10\", len(unique_comms))\nnode_colors = [color_map(membership_greedy[n]) for n in G.nodes()]\n\nplt.figure(figsize=(8, 6))\nnx.draw_networkx(\n    G,\n    pos=pos,\n    node_color=node_colors,\n    node_size=300,\n    edge_color=\"lightgray\",\n    with_labels=True,\n    font_size=8,\n)\nplt.title(f\"Greedy Modularity Communities\\nModularity = {mod_greedy:.3f}\")\nplt.axis(\"off\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](practice_2_files/figure-html/viz-greedy-output-1.png){#viz-greedy width=614 height=501}\n:::\n:::\n\n\n## Method 2: Label Propagation\n\nAsynchronous label propagation is a fast, diffusion-like community detection method.\n\n::: {#label-propagation .cell execution_count=7}\n``` {.python .cell-code}\nlpa_comms = list(nx_comm.asyn_lpa_communities(G, weight=None, seed=42))\nmod_lpa = print_partition_stats(G, lpa_comms, \"Label Propagation\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n=== Label Propagation ===\nNumber of communities: 4\nCommunity sizes: [12, 5, 14, 3]\nModularity: 0.437\n\n```\n:::\n:::\n\n\n### Visualization\n\n::: {#cell-viz-lpa .cell fig-height='6' fig-width='8' execution_count=8}\n``` {.python .cell-code}\nmembership_lpa = partition_to_membership(G, lpa_comms)\n\nunique_comms = sorted(set(membership_lpa.values()))\ncolor_map = plt.cm.get_cmap(\"tab10\", len(unique_comms))\nnode_colors = [color_map(membership_lpa[n]) for n in G.nodes()]\n\nplt.figure(figsize=(8, 6))\nnx.draw_networkx(\n    G,\n    pos=pos,\n    node_color=node_colors,\n    node_size=300,\n    edge_color=\"lightgray\",\n    with_labels=True,\n    font_size=8,\n)\nplt.title(f\"Label Propagation Communities\\nModularity = {mod_lpa:.3f}\")\nplt.axis(\"off\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](practice_2_files/figure-html/viz-lpa-output-1.png){#viz-lpa width=614 height=501}\n:::\n:::\n\n\n## Method 3: Girvan-Newman (Edge Betweenness)\n\nThe Girvan-Newman algorithm progressively removes edges with high betweenness.\n\n::: {#girvan-newman .cell execution_count=9}\n``` {.python .cell-code}\nfrom itertools import islice\n\n# Generate successive partitions (hierarchy)\ncomp = nx_comm.girvan_newman(G)\n\n# Take the partition with 2 communities (first split)\nfirst_level = next(comp)\n\n# Optionally, get partition with 3 communities\nsecond_level = next(comp)\n\n# Choose which level to analyze\ngn_comms = list(first_level)\nmod_gn = print_partition_stats(G, gn_comms, \"Girvan-Newman (2-way split)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n=== Girvan-Newman (2-way split) ===\nNumber of communities: 2\nCommunity sizes: [15, 19]\nModularity: 0.348\n\n```\n:::\n:::\n\n\n### Visualization\n\n::: {#cell-viz-gn .cell fig-height='6' fig-width='8' execution_count=10}\n``` {.python .cell-code}\nmembership_gn = partition_to_membership(G, gn_comms)\n\nunique_comms = sorted(set(membership_gn.values()))\ncolor_map = plt.cm.get_cmap(\"tab10\", len(unique_comms))\nnode_colors = [color_map(membership_gn[n]) for n in G.nodes()]\n\nplt.figure(figsize=(8, 6))\nnx.draw_networkx(\n    G,\n    pos=pos,\n    node_color=node_colors,\n    node_size=300,\n    edge_color=\"lightgray\",\n    with_labels=True,\n    font_size=8,\n)\nplt.title(f\"Girvan-Newman Communities (2-way)\\nModularity = {mod_gn:.3f}\")\nplt.axis(\"off\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](practice_2_files/figure-html/viz-gn-output-1.png){#viz-gn width=614 height=501}\n:::\n:::\n\n\n## Optional: Louvain Algorithm (If Available)\n\n::: {#louvain .cell execution_count=11}\n``` {.python .cell-code}\nif HAVE_LOUVAIN:\n    print(\"Louvain package detected. Running Louvain community detection...\\n\")\n    louvain_partition = community_louvain.best_partition(G)\n\n    # Convert partition dict -> communities list\n    comm_dict = {}\n    for node, cid in louvain_partition.items():\n        comm_dict.setdefault(cid, set()).add(node)\n    louvain_comms = list(comm_dict.values())\n\n    mod_louvain = nx_comm.modularity(G, louvain_comms)\n    print(f\"=== Louvain ===\")\n    print(f\"Number of communities: {len(louvain_comms)}\")\n    print(f\"Modularity: {mod_louvain:.3f}\\n\")\n\n    # Visualization\n    unique_comms = sorted(set(louvain_partition.values()))\n    color_map = plt.cm.get_cmap(\"tab10\", len(unique_comms))\n    node_colors = [color_map(louvain_partition[n]) for n in G.nodes()]\n\n    plt.figure(figsize=(8, 6))\n    nx.draw_networkx(\n        G,\n        pos=pos,\n        node_color=node_colors,\n        node_size=300,\n        edge_color=\"lightgray\",\n        with_labels=True,\n        font_size=8,\n    )\n    plt.title(f\"Louvain Communities\\nModularity = {mod_louvain:.3f}\")\n    plt.axis(\"off\")\n    plt.show()\nelse:\n    print(\"python-louvain package not installed; skipping Louvain example.\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npython-louvain package not installed; skipping Louvain example.\n\n```\n:::\n:::\n\n\n# Comparing Methods\n\n## Summary Table\n\n::: {#cell-comparison .cell execution_count=12}\n``` {.python .cell-code}\nresults = [\n    {\"method\": \"Greedy\", \"modularity\": mod_greedy, \"n_communities\": len(greedy_comms)},\n    {\"method\": \"Label Propagation\", \"modularity\": mod_lpa, \"n_communities\": len(lpa_comms)},\n    {\"method\": \"Girvan-Newman (2-way)\", \"modularity\": mod_gn, \"n_communities\": len(gn_comms)},\n]\n\nif HAVE_LOUVAIN:\n    results.append({\"method\": \"Louvain\", \"modularity\": mod_louvain, \"n_communities\": len(louvain_comms)})\n\ncomparison_df = pd.DataFrame(results)\ncomparison_df\n```\n\n::: {#comparison .cell-output .cell-output-display execution_count=26}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>method</th>\n      <th>modularity</th>\n      <th>n_communities</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Greedy</td>\n      <td>0.410965</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Label Propagation</td>\n      <td>0.436602</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Girvan-Newman (2-way)</td>\n      <td>0.347660</td>\n      <td>2</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Modularity Bar Plot\n\n::: {#cell-modularity-plot .cell fig-height='4' fig-width='8' execution_count=13}\n``` {.python .cell-code}\nplt.figure(figsize=(8, 4))\nplt.bar(comparison_df[\"method\"], comparison_df[\"modularity\"], color=\"steelblue\")\nplt.xticks(rotation=30, ha=\"right\")\nplt.ylabel(\"Modularity\")\nplt.title(\"Modularity by Community Detection Method\")\nfor i, v in enumerate(comparison_df[\"modularity\" ]):\n    plt.text(i, v + 0.01, f\"{v:.3f}\", ha=\"center\", va=\"bottom\", fontsize=9)\nplt.ylim(0, max(comparison_df[\"modularity\"]) + 0.1)\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](practice_2_files/figure-html/modularity-plot-output-1.png){#modularity-plot width=757 height=373}\n:::\n:::\n\n\n# Example 2: Larger Network (Scale-Free)\n\n::: {#cell-larger-network .cell fig-height='6' fig-width='8' execution_count=14}\n``` {.python .cell-code}\n# Generate a scale-free network using Barab√°si-Albert model\nnp.random.seed(42)\nH = nx.barabasi_albert_graph(n=200, m=2)\n\nprint(f\"Nodes: {H.number_of_nodes()}, Edges: {H.number_of_edges()}\")\n\n# Detect communities using greedy modularity\ngreedy_large = list(nx_comm.greedy_modularity_communities(H))\nmod_large = nx_comm.modularity(H, greedy_large)\nprint(f\"Greedy modularity communities: {len(greedy_large)}\")\nprint(f\"Modularity: {mod_large:.3f}\")\n\n# Visualize (without labels for clarity)\npos_large = nx.spring_layout(H, seed=42)\nmem_large = partition_to_membership(H, greedy_large)\nunique_large = sorted(set(mem_large.values()))\ncolor_map = plt.cm.get_cmap(\"tab20\", len(unique_large))\nnode_colors = [color_map(mem_large[n]) for n in H.nodes()]\n\nplt.figure(figsize=(8, 6))\nnx.draw_networkx(\n    H,\n    pos=pos_large,\n    node_color=node_colors,\n    node_size=40,\n    edge_color=\"lightgray\",\n    with_labels=False,\n)\nplt.title(f\"Scale-Free Network (n=200)\\nGreedy Modularity, Modularity = {mod_large:.3f}\")\nplt.axis(\"off\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNodes: 200, Edges: 396\nGreedy modularity communities: 10\nModularity: 0.475\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](practice_2_files/figure-html/larger-network-output-2.png){#larger-network width=614 height=501}\n:::\n:::\n\n\n# Key Takeaways\n\n1. Different algorithms can yield different numbers of communities and modularity values.\n2. Greedy modularity is often a good default method in NetworkX.\n3. Label propagation is fast and parameter-free but can be unstable.\n4. Girvan-Newman provides a hierarchical view but is computationally expensive.\n5. Louvain (if available) is a widely used modularity-maximizing algorithm.\n\n# Exercises\n\n1. **Compare Methods on a New Network**  \n   Load another NetworkX example graph (e.g., `nx.les_miserables_graph()` or `nx.davis_southern_women_graph()`) and:\n   - Apply at least three community detection methods\n   - Compare modularity scores\n   - Visualize community assignments\n\n2. **Resolution Exploration (Advanced)**  \n   Implement a simple resolution sweep for the greedy algorithm by modifying the graph (e.g., thresholding edge weights or adding/removing edges) and observe how community structure changes.\n\n3. **Community Characteristics**  \n   For your favorite partition on the karate club graph:\n   - Compute within- and between-community edge densities\n   - Identify bridge nodes that connect different communities\n   - Interpret what these communities might represent substantively.\n\n---\n\n**Next Steps**: After working through this Python tutorial, revisit `practice_1.qmd` (R) and compare the workflows and results across languages.\n\n",
    "supporting": [
      "practice_2_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js\" integrity=\"sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js\" integrity=\"sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}
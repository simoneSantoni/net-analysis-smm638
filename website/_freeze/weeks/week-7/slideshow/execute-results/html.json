{
  "hash": "c35c6d0cf5034a33e30397dde2b50899",
  "result": {
    "engine": "knitr",
    "markdown": "\n---\ntitle: \"Communities, Roles, and Positions in Networks\"\nauthor: \"SMM638 Network Analytics\"\nformat:\n  revealjs:\n    theme: default\n    slide-number: true\n    transition: slide\n    chalkboard: true\n    multiplex: false\n    css: ../../slideshow-theme.css\n    code-fold: true\n    code-summary: \"\"\n\n---\n\n## Part 1: Network Communities\n\n---\n\n## Overview of Weeks 1–5 {.smaller}\n\nWhat we have learned:\n\n- How to represent a system as a **network**\n  - Nodes, edges, paths, walks, geodesics\n  - Directed vs. undirected, weighted vs. unweighted\n- How to assess the **position of individual nodes**\n  - Degree, closeness, betweenness, eigenvector centrality\n  - Interpretation: access to resources, brokerage, prestige\n- How to assess **mechanisms shaping network structure**\n  - Reciprocity, triadic closure, preferential attachment\n  - Homophily: “birds of a feather flock together”\n  - Random vs. structured networks as useful baselines\n\nWhat we will learn (Weeks 7 and 8):\n\n- How to build **simplified models of a network** using:\n  - **Communities** (cohesive groups)\n  - **Roles** (who plays similar structural functions)\n  - **Positions** (higher-level pattern of relations among roles)\n- How these structures shape:\n  - **Opportunities** and **constraints** for individual nodes\n  - **Performance consequences** (e.g., diffusion, access, power)\n\n---\n\n## Durkheim's Theory of Social Integration\n\n**Mechanical Solidarity** (traditional societies)\n- Integration through **similarity** and shared attributes\n- Everyone does similar work, shares same values\n- Maps onto → **Communities** in networks\n\n**Organic Solidarity** (modern societies)  \n- Integration through **differentiation** and interdependence\n- Specialized roles in division of labor\n- Maps onto → **Positions** in networks\n\n**Implication**: Communities ≠ Positions are orthogonal dimensions\n\n---\n\n## Example: Academic Department\n\n```r\n# Two orthogonal dimensions of structure\n\n# Communities (based on direct interaction)\nML_group <- c(\"Prof_A\", \"PhD_1\", \"PhD_2\")\nTheory_group <- c(\"Prof_B\", \"PhD_3\", \"PhD_4\")\n\n# Positions (based on role similarity)\nSenior <- c(\"Prof_A\", \"Prof_B\")  # Both advise\nJunior <- c(\"PhD_1\", \"PhD_2\", \"PhD_3\", \"PhD_4\")  # All advised\n```\n\nA junior ML researcher and junior theorist:\n- **Different communities** (ML vs. Theory)\n- **Same position** (advisee role)\n\n---\n\n## On the Concept of Community\n\n\n**Intuition**\n\nA *community* is a subset of nodes that are more densely connected to each other than to outsiders.\n\n**Examples**\n\n- Friendship groups in a high school\n- R&D collaboration clusters\n- Online communities\n- Scientific collaboration clusters\n\n---\n\n## The Case of Small-World Networks\n\n**Intuition**\n\nSmall worlds combine:\n\n1. **High clustering**\n2. **Short average path lengths**\n\n**Examples**\n\n- Milgram experiment  \n- Watts–Strogatz model\n\n---\n\n## The Connection Between Homophily and Small Worlds\n\nHomophily → dense cohesive groups → small-world structure\n\n---\n\n## Examples of Homophily in Small Worlds\n\n- Educational settings  \n- Study groups  \n- Cliques along demographic lines  \n\n---\n\n## Granovetter: The Strength of Weak Ties\n\n**The Paradox**\n\n\"Weak ties\" (acquaintances) provide **more novel information** than \"strong ties\" (close friends).\n\n**Why?**\n\n- Strong ties cluster together (your friends know each other)\n- Weak ties bridge to distant parts of the network\n- Information from close friends is redundant\n\n**Implication**: Bridges between communities are crucial for information flow\n\n---\n\n## Weak Ties: Visual Demonstration\n\n```r\nlibrary(igraph)\n\n# Two dense communities\ng1 <- make_full_graph(10)\ng2 <- make_full_graph(10)\ng <- disjoint_union(g1, g2)\n\n# Add weak tie bridges\ng <- add_edges(g, c(5,15, 7,17, 2,12))\n\n# Calculate betweenness\nbtw <- edge_betweenness(g)\n\n# Weak ties have highest betweenness!\n# They are bottlenecks for information flow\n```\n\n**Result**: Removing 3 weak ties doubles average path length\n\n---\n\n## The Case of Small-World Networks\n\n**Intuition**\n\nSmall worlds combine:\n\n1. **High clustering** (dense local neighborhoods)\n2. **Short average path lengths** (few steps between any two nodes)\n\n**Examples**\n\n- Milgram experiment (\"six degrees of separation\")\n- Watts–Strogatz model\n- Social networks, neural networks, power grids\n\n**Why it matters**: Local cohesion + global reach\n\n---\n\n## Small-World Structure Comparison\n\n| Network Type | Clustering | Path Length | Example |\n|--------------|------------|-------------|---------|\n| **Regular lattice** | High | High | Grid |\n| **Random** | Low | Low | Erdős-Rényi |\n| **Small-world** | **High** | **Low** | Real social networks |\n\nSmall-world = \"Best of both worlds\"\n\n---\n\n## Creating a Small-World Network\n\n```r\n# Watts-Strogatz model\nlibrary(igraph)\n\nn <- 100      # nodes\nk <- 6        # neighbors\np <- 0.1      # rewiring probability\n\n# Start with ring, rewire 10% of edges\ng <- watts.strogatz.game(1, n, k/2, p)\n\n# Result: high clustering (like regular)\n#         + short paths (like random)\n```\n\nOnly 10% rewired edges needed to achieve small-world property!\n\n---\n\n## The Connection Between Homophily and Small Worlds\n\nHomophily (similarity-based tie formation):\n- Creates **dense cohesive groups** (high clustering)\n- But a few cross-group ties (weak ties) → **short paths**\n\nResult: Small-world structure emerges naturally\n\n**Examples**\n- Educational settings (study groups by major, occasional cross-major friendships)\n- Organizational networks (departments cluster, management bridges)\n\n---\n\n## Definitions of Network Communities\n\n\n- **Strong**: Cliques (all nodes connected to all others)\n- **Weak**: Subgraphs where internal density > external density\n- **LS Sets**: Subsets where any proper subset has more ties to the set than to outsiders\n\n\n---\n\n## Example of Communities in a Strong Sense\n\nStrongly cohesive groups, nearly clique-like.\n\n---\n\n## Example of Communities in a Weak Sense\n\nHigh internal density but not complete; overlapping clusters.\n\n---\n\n## Most Popular Community Detection Algorithms\n\n- Louvain  \n- Leiden  \n- Girvan–Newman  \n- Spectral clustering  \n- Walktrap / Label propagation  \n\n---\n\n## The Connection between Network Communities and Modularity\n\n**Modularity** is the most common metric for defining communities. It compares the observed number of edges within groups to what we would expect in a random network with the same degree distribution.\n\n\n---\n\n## Understanding Modularity\n\n**What is Modularity (Q)?**\n\nMeasures if a partition has more **within-group edges** than expected by chance.\n\n$$Q = \\frac{1}{2m} \\sum_{ij} \\left[A_{ij} - \\frac{k_i k_j}{2m}\\right] \\delta(c_i, c_j)$$\n\n- $A_{ij}$ = observed edge\n- $\\frac{k_i k_j}{2m}$ = expected edge (null model)\n- $\\delta(c_i, c_j)$ = 1 if same community, 0 otherwise\n\n---\n\n## Modularity Interpretation\n\n| Q Value | Interpretation |\n|---------|----------------|\n| **Q < 0.3** | No meaningful community structure |\n| **Q = 0.3-0.7** | Significant community structure |\n| **Q > 0.7** | Very strong divisions (rare) |\n\n**Rule of thumb**: Q > 0.4 indicates good community detection\n\n---\n\n## Most Popular Community Detection Algorithms\n\n| Algorithm | Objective | Speed | Best Use |\n|-----------|-----------|-------|----------|\n| **Louvain** | Modularity max | Fast | General purpose |\n| **Leiden** | Improved modularity | Fast | Quality + speed |\n| **Walktrap** | Random walks | Medium | Multi-scale |\n| **Girvan-Newman** | Edge betweenness | Slow | Hierarchical, small networks |\n| **Label Propagation** | Local consensus | Very fast | Large networks, unstable |\n\n**Recommendation**: Start with Louvain or Leiden\n\n---\n\n## Resolution Parameter\n\nMany algorithms have a **resolution** parameter controlling granularity:\n\n```r\n# Higher resolution → more, smaller communities\ncommunities_fine <- cluster_louvain(g, resolution=2.0)  # 8 communities\n\n# Default resolution\ncommunities_default <- cluster_louvain(g, resolution=1.0)  # 4 communities\n\n# Lower resolution → fewer, larger communities  \ncommunities_coarse <- cluster_louvain(g, resolution=0.5)  # 2 communities\n```\n\n**Choice depends on your research question**\n\n---\n\n## Community Detection Algorithms in Action\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(igraph)\n\n# Load network\ng <- make_graph(\"Zachary\")  # or read from file\n\n# Method 1: Louvain (fast, modularity-based)\ncomm_louvain <- cluster_louvain(g)\n\n# Method 2: Leiden (improved Louvain)\ncomm_leiden <- cluster_leiden(g)\n\n# Method 3: Walktrap (random walk-based)\ncomm_walktrap <- cluster_walktrap(g, steps = 4)\n\n# Method 4: Edge Betweenness (hierarchical)\ncomm_edgebet <- cluster_edge_betweenness(g)\n\n# Method 5: Fast Greedy (hierarchical modularity)\ncomm_fastgreedy <- cluster_fast_greedy(g)\n\n# Extract results\nmembership(comm_louvain)         # Community assignments\nlength(comm_louvain)             # Number of communities\nsizes(comm_louvain)              # Community sizes\nmodularity(comm_louvain)         # Modularity score\n\n# Compare methods\ncompare(comm_louvain, comm_leiden, method = \"nmi\")  # Agreement\n\n# Visualize\nplot(comm_louvain, g,\n     vertex.size = 8,\n     edge.color = \"gray80\",\n     main = \"Communities\")\n```\n:::\n\n\n---\n\n## Part II: Roles and Positions\n\n---\n\n## Definitions\n\n**Role**: Set of nodes with similar structural functions  \n**Position**: Pattern of relations defining a node's structural location  \n\n---\n\n## Rendering Roles in Network Data\n\n**Intuition**\n- Complex networks are hard to understand node-by-node\n- We group nodes that \"do the same thing\"\n- Example: In a hospital, all nurses have similar ties to doctors and patients\n\n**Approaches**\n- Blockmodeling (discrete partitions)\n- Hierarchical clustering (continuous similarity)\n\n\n---\n\n## Rendering Roles: Algorithms\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(igraph)\n\ng <- sample_pa(20, directed = TRUE)\nadj <- as.matrix(as_adjacency_matrix(g))\n\n# Method 1: Correlation-based equivalence\nequiv_cor <- cor(t(adj))          # Correlate row profiles\ndist_cor <- as.dist(1 - equiv_cor)\nhc_cor <- hclust(dist_cor, method = \"complete\")\npositions_cor <- cutree(hc_cor, k = 4)\n\n# Method 2: Euclidean distance equivalence\ndist_euclidean <- dist(adj, method = \"euclidean\")\nhc_euclidean <- hclust(dist_euclidean, method = \"ward.D2\")\npositions_euclidean <- cutree(hc_euclidean, k = 4)\n\n# Visualize dendrogram\nplot(hc_cor, main = \"Position Hierarchy\", xlab = \"Node\")\nrect.hclust(hc_cor, k = 4, border = \"red\")\n\n# Create image matrix\nn_pos <- max(positions_cor)\nimage_matrix <- matrix(0, nrow = n_pos, ncol = n_pos)\n\nfor(i in 1:n_pos) {\n  for(j in 1:n_pos) {\n    block <- adj[positions_cor == i, positions_cor == j]\n    image_matrix[i, j] <- mean(block)\n  }\n}\n\nprint(round(image_matrix, 2))\n\n# Visualize with position colors\nV(g)$color <- rainbow(n_pos)[positions_cor]\nplot(g, vertex.size = 8, main = \"Network by Position\")\n```\n:::\n\n\n---\n\n## Rendering Positions in Network Data\n\n**Triad Census**\n- Analyzing the frequency of different triad types (e.g., transitive, cyclic)\n- Different roles (e.g., broker vs. isolate) show different triad profiles\n\n**Multiplexity**\n- Roles often defined by multiple types of ties (e.g., friend + coworker)\n\n\n---\n\n## Rendering Positions: Algorithms\n\n**Similarity Matrices**\n- Compute similarity between every pair of nodes (correlation, distance)\n\n**Clustering**\n- Group similar nodes using hierarchical or k-means clustering\n\n**Blockmodels**\n- Permute the adjacency matrix to reveal blocks of high/low density\n\n\n---\n\n## Structural Equivalence: Definition\n\n**Two nodes are structurally equivalent if they have identical ties to the same alters**\n\nExample:\n- Node A connects to: {C, D, E}\n- Node B connects to: {C, D, E}\n- → A and B are structurally equivalent\n\n**Implication**: They are **substitutable** - occupy the same position\n\n---\n\n## Types of Equivalence\n\n| Type | Definition | Example |\n|------|------------|---------|\n| **Structural** | Identical ties to same alters | Two salespeople serving same clients |\n| **Regular** | Similar types of ties | All managers supervise someone |\n| **Automorphic** | Topologically identical | Symmetry in graph |\n\nMost common in practice: **Structural equivalence**\n\n---\n\n## Measuring Structural Equivalence\n\n```r\nlibrary(igraph)\n\n# Adjacency matrix\nA <- matrix(c(0, 1, 1, 0,\n              1, 0, 1, 0,\n              0, 0, 0, 1,\n              0, 0, 1, 0), nrow=4, byrow=TRUE)\n\n# Correlation (nodes with similar tie profiles)\n# cor() correlates columns, so transpose for row profiles\nequivalence <- cor(t(A))  # Higher = more equivalent\n```\n\n---\n\n## Rendering Roles in Network Data\n\n**From actors to positions**\n\n1. Calculate similarity matrix (correlation or Euclidean distance)\n2. Apply hierarchical clustering\n3. Cut dendrogram to get positions\n4. Interpret role meanings\n\n**Result**: Reduced representation (30 actors → 4 positions)\n\n---\n\n## Blockmodeling: Image Matrices\n\n**Blockmodel** reduces network to position-level interactions\n\n**Example**: 30-person organization → 3 positions (Senior, Mid, Junior)\n\n**Image Matrix** (3×3):\n```\n           Senior  Mid  Junior\nSenior  [   0.8   0.6   0.3  ]\nMid     [   0.4   0.5   0.7  ]\nJunior  [   0.1   0.6   0.4  ]\n```\n\nInterpretation: Senior staff advise all levels, juniors mainly interact with mid-level\n\n---\n\n## CONCOR Algorithm\n\n**CONvergence of iterated CORrelations**\n\n1. Calculate correlation matrix of node profiles\n2. Correlate the correlation matrix  \n3. Repeat until convergence\n4. Split based on sign of first eigenvector\n\n**Why it works**: Iterating amplifies structural patterns\n\n**Result**: Hierarchical partition (can split recursively)\n\n---\n\n## Rendering Positions: Algorithms\n\n**Methods for finding positions**:\n\n1. **Correlation-based clustering**\n   - Correlate row (or column) profiles\n   - Hierarchical clustering\n\n2. **Euclidean distance clustering**\n   - Calculate Euclidean distance between profiles\n   - Ward linkage clustering\n\n3. **CONCOR** (classical approach)\n\n**Choice**: Correlation for directed networks, Euclidean for valued networks\n\n---\n\n## Communities vs. Positions: Key Differences\n\n| Dimension | Communities | Positions |\n|-----------|-------------|-----------|\n| **Basis** | Direct ties | Tie patterns |\n| **Logic** | Cohesion | Equivalence |\n| **Question** | Who interacts with whom? | Who plays similar roles? |\n| **Example** | Research groups | Hierarchical levels |\n| **Solidarity** | Mechanical | Organic |\n\n**Both are valid, complementary perspectives**\n\n---\n\n## When Communities ≠ Positions\n\n**Example**: Corporate structure\n\n- **Communities**: Departments (Marketing, R&D, Finance)\n- **Positions**: Ranks (Executives, Managers, Staff)\n\nA Marketing Manager and an R&D Manager:\n- **Different communities** (different departments)\n- **Same position** (both supervise, both report up)\n\n**Adjusted Rand Index**: Measures overlap (0 = independent, 1 = identical)\n\n---\n\n## Wrap up\n\n\nCommunities = cohesion  \nRoles/positions = equivalence  \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
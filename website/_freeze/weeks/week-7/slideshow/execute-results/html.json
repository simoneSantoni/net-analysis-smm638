{
  "hash": "c1d2bf81bd6a694cf3cad85bbf37d1cb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Communities, Roles, and Positions in Networks\"\nauthor: \"SMM638 Network Analytics\"\nformat:\n  revealjs:\n    theme: default\n    slide-number: true\n    transition: slide\n    chalkboard: true\n    multiplex: false\n    css: ../../slideshow-theme.css\n    code-fold: true\n    code-summary: \"\"\n---\n\n## Part I: Network Communities {.center .middle}\n\n---\n\n## Overview of Weeks 1–5 {.smaller}\n\n::: {.callout-important}\n**What we have learned:**\n\n- **Network Representation**: Nodes (actors), edges (relationships), and the \"physics\" of connectivity.\n- **Node Positioning**: Centrality metrics (Degree, Betweenness, Eigenvector) to identify *key players*.\n- **Formation Mechanisms**: Why links form (Homophily, Triadic Closure, Preferential Attachment).\n:::\n\n::: {.callout-caution}\n**What we will learn (Weeks 7 & 8):**\n\n- **Macro-Structure (Communities)**:\n  - Detecting cohesive subgroups (cliques, clusters).\n  - *Business Use*: Market segmentation, fraud rings, organizational silos.\n- **Meso-Structure (Roles & Positions)**:\n  - Identifying actors with similar *functions* (even if unconnected).\n  - *Business Use*: Talent management, supply chain redundancy, competitive analysis.\n- **Strategic Implications**:\n  - How structure dictates performance, innovation, and resilience.\n:::\n---\n\n## Why Do Networks Are More Than the Sum of Their Parts? {.smaller}\n\nSociologist Émile Durkheim proposed two forms of social integration that map \nperfectly onto network analysis, and explain why networks are more than the \nsum of their parts:\n\n::: {.callout-note icon=\"false\"}\n## 1. Mechanical Solidarity (Cohesion)\n\n- Integration through **similarity** and direct interaction.\n- \"We are connected because we are the same.\"\n- **Network Concept**: **Communities** (Clusters, Cliques).\n:::\n\n::: {.callout-note icon=\"false\"}\n## 2. Organic Solidarity (Equivalence)\n\n- Integration through **interdependence** and specialized roles.\n- \"We are connected because we need each other's different functions.\"\n- **Network Concept**: **Positions** (Roles, Blockmodels).\n:::\n*Key Insight: A network can be analyzed through **cohesion** (who hangs out with whom) or **equivalence** (who does the same job).*\n\n---\n\n## Example: Academic Department\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(igraph)\n\n# 1. Construct the Network (Edges based on Community Cohesion)\nedges <- data.frame(\n  from = c(\"Prof_A\", \"Prof_A\", \"PhD_1\",   # ML Group\n           \"Prof_B\", \"Prof_B\", \"PhD_3\"),  # Theory Group\n  to   = c(\"PhD_1\",  \"PhD_2\",  \"PhD_2\",\n           \"PhD_3\",  \"PhD_4\",  \"PhD_4\")\n)\ng <- graph_from_data_frame(edges, directed = FALSE)\n\n# 2. Define Attributes (Data from Example)\n# Communities (Color)\nV(g)$color <- ifelse(V(g)$name %in% c(\"Prof_A\", \"PhD_1\", \"PhD_2\"), \n                     \"#E41A1C\", \"#377EB8\") # Red for ML, Blue for Theory\n\n# Positions (Shape)\n# Profs are Squares, Students are Circles\nV(g)$shape <- ifelse(V(g)$name %in% c(\"Prof_A\", \"Prof_B\"), \n                     \"square\", \"circle\")\n\n# 3. Visualize\npar(mar=c(1,1,1,1))\nplot(g, layout = layout_nicely(g),\n     vertex.label.color = \"white\", vertex.label.font = 2,\n     vertex.size = 30, edge.width = 2,\n     main = \"Communities (Color) vs. Positions (Shape)\")\n\nlegend(\"bottomleft\", legend = c(\"ML\", \"History\"), \n       col = c(\"#E41A1C\", \"#377EB8\"), pch = 19, bty = \"n\", title = \"Community\")\nlegend(\"bottomright\", legend = c(\"Senior\", \"Junior\"), \n       col = \"black\", pch = c(15, 16), bty = \"n\", title = \"Position\")\n```\n\n::: {.cell-output-display}\n![](slideshow_files/figure-revealjs/unnamed-chunk-1-1.png){fig-align='center' width=960}\n:::\n:::\n\n\nA junior ML researcher and junior historian:\n\n- **Different communities** (ML vs. History)\n- **Same position** (student role)\n\n---\n\n## On the Concept of Community\n\n**Definition**\n\nA *community* is a subset of nodes that are more densely connected to each other than to the rest of the network.\n\n**Business Applications**\n\n- **Marketing**: Identifying customer segments based on purchase behavior (e.g., \"Tech Enthusiasts\" vs. \"Home Decorators\").\n- **HR / People Analytics**: Uncovering informal collaboration teams that don't match the org chart.\n- **Fraud Detection**: Detecting \"rings\" of accounts that trade/interact only with each other to boost ratings or launder money.\n- **Supply Chain**: Identifying regional clusters of suppliers to assess local risks.\n\n---\n\n## The \"Small World\" Phenomenon {.smaller}\n\n**The Concept**\n\nMost real-world networks (social, biological, technological) exhibit the \"Small World\" property:\n\n1.  **High Clustering**: My friends are likely to be friends with each other (like a caveman village).\n2.  **Short Path Lengths**: I can reach anyone in the world in ~6 steps (like a random graph).\n\n**Why?**\n\n- **Homophily** creates the clusters (local cohesion).\n- **Weak Ties** (bridges) create the shortcuts (global reach).\n\n**Business Implication**\n\n- **Information Diffusion**: News travels fast in small worlds.\n- **Viral Marketing**: You need to seed ideas in different clusters (high clustering) but ensure they can jump across bridges (short paths).\n\n---\n\n## Strong Communities: The Clique\n\n**Definition**\nA **Clique** is a subgraph where every distinct pair of nodes is adjacent. It represents the strictest form of cohesion.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](slideshow_files/figure-revealjs/unnamed-chunk-2-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n---\n\n## Weak Communities: Density-Based\n\n**Definition**\nA **Weak Community** is a subgraph where the density of internal edges is significantly higher than the density of external edges (ties to the rest of the network).\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](slideshow_files/figure-revealjs/unnamed-chunk-3-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n---\n\n## LS Sets: Robustness\n\n**Definition**\nAn **LS Set** is a subset of nodes where any proper subset has more ties to the *rest of the group* than to the *outside*. It represents defensive cohesion—it is harder to split the group than to disconnect it from the network.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](slideshow_files/figure-revealjs/unnamed-chunk-4-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n---\n\n## Most Popular Community Detection Algorithms\n\n- Louvain  \n- Leiden  \n- Girvan–Newman  \n- Spectral clustering  \n- Walktrap / Label propagation  \n\n---\n\n## Understanding Modularity (Q) {.smaller}\n\nMany of the community detection algorithms we just discussed, such as Louvain, aim to optimize a metric called Modularity (Q).\n\n**The Metric**\n\nModularity measures the strength of division of a network into modules (communities).\n\n$$Q = \\text{(Fraction of edges within groups)} - \\text{(Expected fraction if edges were random)}$$\n\n**Interpretation**\n\n- **$Q \\approx 0$**: The network is random; no community structure.\n- **$Q \\in [0.3, 0.7]$**: Strong community structure (common in social networks).\n- **$Q \\to 1$**: Disconnected components (islands).\n\n**The \"Resolution Limit\"**\n\n- Modularity optimization has a blind spot: it may fail to detect small communities in very large networks, merging them into larger clusters.\n- *Solution*: Use multi-resolution algorithms (e.g., Louvain with resolution parameter).\n\n---\n\n## Community Detection Algorithms: A Field Guide {.smaller}\n\n| Algorithm | Mechanism | Pros | Cons | Best For |\n|-----------|-----------|------|------|----------|\n| **Louvain** | Modularity Optimization | Very Fast | Resolution limit | Large networks (Default choice) |\n| **Leiden** | Refined Louvain | Faster, guarantees connected comms | - | Large networks (Modern standard) |\n| **Girvan-Newman** | Edge Betweenness (Divisive) | Intuitive hierarchy | Very Slow ($O(N^3)$) | Small networks (<500 nodes), teaching |\n| **Label Propagation** | Local Voting | Linear time | Unstable (random seed matters) | Massive networks |\n| **Spectral** | Eigenvectors | Math rigor | Slower | Fixed $k$ communities |\n\n:::{.callout-tip}\n\nStart with **Louvain** or **Leiden**. \n\nUse **Girvan-Newman** only if you need to analyze the hierarchy of splits in a small graph.\n:::\n\n---\n\n## Resolution Parameter\n\nMany algorithms have a **resolution** parameter controlling granularity:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](slideshow_files/figure-revealjs/unnamed-chunk-5-1.png){fig-align='center' width=1152}\n:::\n:::\n\n\n::: {.callout-important}\n## **Choice depends on your research question**\n\n- **Macro-Level (Low Resolution)**: Use when you want to identify broad market segments or major political coalitions. You care about the \"big picture\" splits.\n- **Micro-Level (High Resolution)**: Use when you need to find specific, tight-knit teams or niche sub-cultures. You care about the fine-grained details.\n:::\n\n---\n\n## Community Detection Algorithms in Action\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(igraph)\n\n# Load network\ng <- make_graph(\"Zachary\")  # or read from file\n\n# Method 1: Louvain (fast, modularity-based)\ncomm_louvain <- cluster_louvain(g)\n\n# Method 2: Leiden (improved Louvain)\ncomm_leiden <- cluster_leiden(g)\n\n# Method 3: Walktrap (random walk-based)\ncomm_walktrap <- cluster_walktrap(g, steps = 4)\n\n# Method 4: Edge Betweenness (hierarchical)\ncomm_edgebet <- cluster_edge_betweenness(g)\n\n# Method 5: Fast Greedy (hierarchical modularity)\ncomm_fastgreedy <- cluster_fast_greedy(g)\n\n# Extract results\nmembership(comm_louvain)         # Community assignments\nlength(comm_louvain)             # Number of communities\nsizes(comm_louvain)              # Community sizes\nmodularity(comm_louvain)         # Modularity score\n\n# Compare methods\ncompare(comm_louvain, comm_leiden, method = \"nmi\")  # Agreement\n\n# Visualize\nplot(comm_louvain, g,\n     vertex.size = 8,\n     edge.color = \"gray80\",\n     main = \"Communities\")\n```\n:::\n\n\n---\n\n## Part II: Roles and Positions {.center .middle}\n\n> \"Community detection finds your friends. Role analysis finds your professional doppelgänger.\"\n\n---\n\n## Definitions: Role vs. Position\n\n**Role**\n\n- A pattern of relationships.\n- Example: \"Broker\", \"Isolate\", \"Hub\", \"Authority\".\n- *Abstract concept*.\n\n**Position**\n\n- A set of actors who occupy the same role in a specific network.\n- Example: \"The Senior Managers\" (a group of 5 specific people who all have the 'Authority' role).\n- *Concrete grouping*.\n\n**Equivalence**\n`\n- The mathematical rule we use to decide if two nodes are in the same position.  \n\n---\n\n## Rendering Roles in Network Data\n\n**Intuition**\n\n- Complex networks are hard to understand node-by-node\n- We group nodes that \"do the same thing\"\n- Example: In a hospital, all nurses have similar ties to doctors and patients\n\n**Approaches**\n\n- Blockmodeling (discrete partitions)\n- Hierarchical clustering (continuous similarity)\n\n---\n\n## Rendering Roles: Algorithms\nThe following outputs demonstrate the blockmodeling process: first, a **dendrogram** reveals the hierarchical clustering of structurally equivalent nodes; second, an **image matrix** summarizes the density of ties between these positions; and finally, the **network graph** visualizes the actors colored by their assigned role.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(igraph)\nset.seed(42)\n\n# Create a network with clear positional structure\n# 3 \"leaders\" (high out-degree), 6 \"followers\" (high in-degree), 3 \"isolates\"\ng <- make_empty_graph(n=12, directed=TRUE)\ng <- add_edges(g, c(\n  1,4, 1,5, 1,6, 1,7,  # Leader 1 → Followers\n  2,5, 2,6, 2,7, 2,8,  # Leader 2 → Followers\n  3,6, 3,7, 3,8, 3,9,  # Leader 3 → Followers\n  4,1, 5,2, 6,3        # Some followers → leaders (feedback)\n))\n\nadj <- as.matrix(as_adjacency_matrix(g))\n\n# Step 1: Compute Similarity Matrix (Correlation of tie patterns)\nsimilarity <- cor(t(adj))  # Transpose to correlate rows\nsimilarity[is.na(similarity)] <- 0  # Handle nodes with no ties\n\n# Step 2: Hierarchical Clustering\ndist_matrix <- as.dist(1 - similarity)  # Convert similarity to distance\nhc <- hclust(dist_matrix, method = \"ward.D2\")\npositions <- cutree(hc, k = 3)  # Cut into 3 positions\n\n# Step 3: Create Blockmodel (Image Matrix)\nn_pos <- max(positions)\nblockmodel <- matrix(0, nrow = n_pos, ncol = n_pos)\nfor(i in 1:n_pos) {\n  for(j in 1:n_pos) {\n    block <- adj[positions == i, positions == j, drop=FALSE]\n    if(length(block) > 0) blockmodel[i, j] <- mean(block)\n  }\n}\n\n# Visualize the three outputs\npar(mfrow=c(1,3), mar=c(4,4,3,2))\n\n# 1. Dendrogram (Hierarchical Clustering)\nplot(hc, main = \"1. Hierarchical Clustering\", xlab = \"Node\", sub = \"\", hang = -1)\nrect.hclust(hc, k = 3, border = \"red\")\n\n# 2. Image Matrix (Blockmodel)\nimage(1:n_pos, 1:n_pos, blockmodel, col = heat.colors(10), \n      main = \"2. Blockmodel\\n(Position-to-Position Density)\",\n      xlab = \"Position\", ylab = \"Position\", axes = FALSE)\naxis(1, at = 1:n_pos); axis(2, at = 1:n_pos)\ntext(expand.grid(1:n_pos, 1:n_pos), labels = round(blockmodel, 2), cex = 1.2)\n\n# 3. Network colored by position\nV(g)$color <- c(\"red\", \"blue\", \"green\")[positions]\nplot(g, vertex.size = 20, edge.arrow.size = 0.5, \n     main = \"3. Network by Position\",\n     vertex.label = 1:12)\nlegend(\"bottomleft\", legend = paste(\"Pos\", 1:3), \n       col = c(\"red\", \"blue\", \"green\"), pch = 19, bty = \"n\")\n```\n\n::: {.cell-output-display}\n![](slideshow_files/figure-revealjs/unnamed-chunk-6-1.png){fig-align='center' width=1152}\n:::\n:::\n\n\n---\n\n## Structural Equivalence: Definition\n\n**Two nodes are structurally equivalent if they have identical ties to the same alters**\n\nExample:\n\n- Node A connects to: {C, D, E}\n- Node B connects to: {C, D, E}\n- → A and B are structurally equivalent\n\n**Implication**: They are **substitutable** - occupy the same position\n\n---\n\n## Types of Equivalence\n\n**1. Structural Equivalence (Strict)**\n- Two nodes are connected to the **exact same** other nodes.\n- *Example*: Two siblings who have the exact same parents and grandparents.\n- *Business*: Two customer service reps who handle the exact same set of tickets (rare).\n\n**2. Regular Equivalence (Functional)**\n- Two nodes are connected to **equivalent** types of nodes.\n- *Example*: Two doctors. Dr. A treats Patient X; Dr. B treats Patient Y. They don't know the same people, but they have the same *relationship* to their patients.\n- *Business*: Two department heads. They manage different teams, but structurally they are identical.\n\n**We typically use Structural Equivalence (via correlation) as a proxy for Regular Equivalence in dense networks.**\n\n---\n\n## Measuring Structural Equivalence {.smaller}\n\n**The Method**: Use **correlation** to measure how similar two nodes' tie patterns are.\n\n- **High correlation (→ 1)**: Nodes connect to the same others → Structurally equivalent\n- **Low correlation (→ 0 or negative)**: Nodes have different tie patterns → Different positions\n\n**Example Network**: 4 nodes with directed ties\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](slideshow_files/figure-revealjs/unnamed-chunk-7-1.png){fig-align='center' width=1152}\n:::\n:::\n\n\n::: {.callout-important}\n## **Interpretation**\n\n- **Nodes A & B**: Correlation ≈ 1.0 → **Highly equivalent** (both connect to B, C)\n- **Nodes C & D**: Correlation ≈ 1.0 → **Highly equivalent** (both connect to C)\n- **Nodes A & C**: Correlation ≈ 0 → **Not equivalent** (different tie patterns)\n\n**Conclusion**: We can group {A, B} into one position and {C, D} into another.\n:::\n\n---\n\n## Summary: The Two Lenses\n\n| Feature | **Community Detection** | **Role Analysis** |\n| :--- | :--- | :--- |\n| **Underlying Logic** | **Cohesion** (Adjacency) | **Equivalence** (Similarity) |\n| **Key Metric** | Modularity | Correlation / Euclidean Dist |\n| **Visual Result** | Clusters / Blobs | Blockmodels / Hierarchies |\n| **Business Question** | \"Who works with whom?\" | \"Who does the same job?\" |\n| **Typical Insight** | Silos, factions, teams | Redundancy, hierarchy, gaps |\n\n**Final Thought**: A complete network analysis usually requires **both**. You want to know who is in the \"Marketing Cluster\" (Community) AND who is the \"Bridge\" (Role) within that cluster.  \n\n---\n\n## When Communities ≠ Positions\n\n**Example**: Corporate structure\n\n- **Communities**: Departments (Marketing, R&D, Finance)\n- **Positions**: Ranks (Executives, Managers, Staff)\n\nA Marketing Manager and an R&D Manager:\n\n- **Different communities** (different departments)\n- **Same position** (both supervise, both report up)",
    "supporting": [
      "slideshow_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
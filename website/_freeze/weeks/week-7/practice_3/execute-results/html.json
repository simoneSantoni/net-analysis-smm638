{
  "hash": "c2028c3ce175fc3fd6b1fe240a823bd0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Role and Position Analysis in R\"\nsubtitle: \"Blockmodeling and Structural Equivalence\"\nformat: \n  html:\n    code-fold: false\n    toc: true\n    toc-depth: 3\n    number-sections: true\nexecute:\n  warning: false\n  message: false\n---\n\n# Introduction\n\nThis tutorial demonstrates how to analyze **roles and positions** in networks using R. Unlike community detection, which looks for cohesive subgroups (cliques, clusters), role analysis seeks to identify actors who behave similarly, even if they are not connected to each other. For example, two teachers in different schools may never interact, but they occupy the same 'role' because they have similar relationships with students, principals, and parents.\n\nWe will explore **structural equivalence**, implement the classic **CONCOR algorithm**, perform **blockmodeling**, and create **image matrices** to uncover the underlying role structure of networks.\n\n## Learning Objectives\n\nBy the end of this tutorial, you will be able to:\n\n- Understand different concepts of structural equivalence\n- Compute similarity measures between actors based on tie patterns\n- Implement the CONCOR algorithm for blockmodeling\n- Perform hierarchical clustering of tie profiles\n- Create and interpret blockmodels and image matrices\n- Visualize role structures in networks\n- Assess the quality of blockmodel fits\n\n## Required Packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load required packages\nlibrary(igraph)\nlibrary(ggplot2)\n\n# Optional packages (install if needed)\nif (!require(\"pheatmap\", quietly = TRUE)) {\n  cat(\"Note: pheatmap not installed. Using base heatmap instead.\\n\")\n  use_pheatmap <- FALSE\n} else {\n  use_pheatmap <- TRUE\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNote: pheatmap not installed. Using base heatmap instead.\n```\n\n\n:::\n\n```{.r .cell-code}\n# Set seed for reproducibility\nset.seed(42)\n```\n:::\n\n\n# Understanding Structural Equivalence\n\n## Concepts\n\n**Structural Equivalence** is the most stringent definition of position. Two actors are structurally equivalent if they have identical ties to and from the exact same other actors. They are perfectly substitutable in the network structure.\n\nIn practice, perfect equivalence is rare. We look for *approximate* equivalence—actors who have *similar* patterns of ties.\n\nThere are other forms of equivalence, such as:\n\n1.  **Structural equivalence**: Actors have identical ties to the same others.\n2.  **Regular equivalence**: Actors have ties to others who are themselves equivalent (e.g., two doctors are equivalent because they both treat patients, even if they treat different patients).\n\nThis tutorial focuses on structural equivalence, which is the foundation of classical blockmodeling.\n\n## Example Network: Corporate Advice Network\n\nLet's create a small directed network representing advice-seeking among managers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create advice network adjacency matrix\nadvice_mat <- matrix(0, nrow = 10, ncol = 10)\nrownames(advice_mat) <- colnames(advice_mat) <- paste0(\"M\", 1:10)\n\n# Senior managers (M1, M2) - give advice, rarely seek it\nadvice_mat[\"M3\", \"M1\"] <- 1\nadvice_mat[\"M4\", \"M1\"] <- 1\nadvice_mat[\"M5\", \"M1\"] <- 1\nadvice_mat[\"M6\", \"M2\"] <- 1\nadvice_mat[\"M7\", \"M2\"] <- 1\nadvice_mat[\"M8\", \"M2\"] <- 1\n\n# Middle managers (M3, M4) - seek from seniors, advise juniors\nadvice_mat[\"M1\", \"M3\"] <- 1  # Senior asks middle (rare)\nadvice_mat[\"M9\", \"M3\"] <- 1\nadvice_mat[\"M10\", \"M3\"] <- 1\nadvice_mat[\"M9\", \"M4\"] <- 1\nadvice_mat[\"M10\", \"M4\"] <- 1\n\n# Middle managers (M5, M6) - similar pattern\nadvice_mat[\"M7\", \"M5\"] <- 1\nadvice_mat[\"M8\", \"M5\"] <- 1\nadvice_mat[\"M7\", \"M6\"] <- 1\nadvice_mat[\"M8\", \"M6\"] <- 1\n\n# Junior managers (M7, M8, M9, M10) - mainly seek advice\nadvice_mat[\"M7\", \"M8\"] <- 1  # Some peer connections\nadvice_mat[\"M8\", \"M7\"] <- 1\nadvice_mat[\"M9\", \"M10\"] <- 1\nadvice_mat[\"M10\", \"M9\"] <- 1\n\n# Create network object  \nadvice_net <- graph_from_adjacency_matrix(advice_mat, mode = \"directed\")\n\ncat(\"Network size:\", vcount(advice_net), \"nodes\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNetwork size: 10 nodes\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Number of ties:\", ecount(advice_net), \"edges\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNumber of ties: 19 edges\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Density:\", round(edge_density(advice_net), 3), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDensity: 0.211 \n```\n\n\n:::\n:::\n\n\n## Visualize the Advice Network\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot the network\nset.seed(42)\nlayout_advice <- layout_with_fr(advice_net)\n\n# Set margins to ensure title is within bounding box\npar(mar = c(1, 1, 4, 1))\nplot(advice_net,\n     layout = layout_advice,\n     vertex.color = \"lightblue\",\n     vertex.size = 15,\n     vertex.label = V(advice_net)$name,\n     vertex.label.cex = 0.8,\n     vertex.label.color = \"black\",\n     edge.color = \"gray50\",\n     edge.width = 1.5,\n     edge.arrow.size = 0.5,\n     main = \"Corporate Advice Network\")\n```\n\n::: {.cell-output-display}\n![](practice_3_files/figure-html/viz-advice-network-1.png){width=768}\n:::\n:::\n\n\n# Measuring Structural Equivalence\n\n## Correlation-Based Similarity\n\nOne common approach is to calculate the **Pearson correlation** between the tie profiles (rows/columns of the adjacency matrix) of pairs of actors.\n\n*   **High positive correlation (+1)**: Actors have very similar tie patterns.\n*   **High negative correlation (-1)**: Actors have opposite tie patterns.\n*   Correlation focuses on the *pattern* or *shape* of ties, normalizing for the total number of ties.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate structural equivalence using correlation\n# For directed networks, we consider both in-ties and out-ties\n\n# Custom function for structural equivalence\ncompute_structural_equiv <- function(adj_mat) {\n  n <- nrow(adj_mat)\n  sim_mat <- matrix(0, n, n)\n  \n  # Combine row and column vectors for each node\n  for(i in 1:n) {\n    for(j in 1:n) {\n      # Correlation between tie profiles\n      profile_i <- c(adj_mat[i,], adj_mat[,i])\n      profile_j <- c(adj_mat[j,], adj_mat[,j])\n      sim_mat[i,j] <- cor(profile_i, profile_j)\n    }\n  }\n  \n  rownames(sim_mat) <- colnames(sim_mat) <- rownames(adj_mat)\n  return(sim_mat)\n}\n\nsimilarity_matrix <- compute_structural_equiv(advice_mat)\n\n# Display similarity matrix\nround(similarity_matrix, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       M1    M2    M3    M4    M5    M6    M7    M8    M9   M10\nM1   1.00 -0.21 -0.25 -0.21 -0.21 -0.21 -0.29 -0.29  0.06  0.06\nM2  -0.21  1.00 -0.21 -0.18  0.61  0.61  0.08  0.08 -0.21 -0.21\nM3  -0.25 -0.21  1.00  0.84  0.14 -0.21 -0.29 -0.29  0.06  0.06\nM4  -0.21 -0.18  0.84  1.00  0.22 -0.18 -0.24 -0.24  0.14  0.14\nM5  -0.21  0.61  0.14  0.22  1.00  0.61  0.08  0.08 -0.21 -0.21\nM6  -0.21  0.61 -0.21 -0.18  0.61  1.00  0.40  0.40 -0.21 -0.21\nM7  -0.29  0.08 -0.29 -0.24  0.08  0.40  1.00  0.47 -0.29 -0.29\nM8  -0.29  0.08 -0.29 -0.24  0.08  0.40  0.47  1.00 -0.29 -0.29\nM9   0.06 -0.21  0.06  0.14 -0.21 -0.21 -0.29 -0.29  1.00  0.38\nM10  0.06 -0.21  0.06  0.14 -0.21 -0.21 -0.29 -0.29  0.38  1.00\n```\n\n\n:::\n:::\n\n\n## Euclidean Distance\n\nAnother approach uses **Euclidean distance** between tie profiles.\n\n*   Measures the geometric distance between actors in the multidimensional space defined by their ties.\n*   Unlike correlation, it is sensitive to the *volume* (number) of ties. Two actors might have the same pattern, but if one has twice as many ties, they will be distant in Euclidean space but highly correlated.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute Euclidean distance\ncompute_euclidean_dist <- function(adj_mat) {\n  n <- nrow(adj_mat)\n  dist_mat <- matrix(0, n, n)\n  \n  for(i in 1:n) {\n    for(j in 1:n) {\n      profile_i <- c(adj_mat[i,], adj_mat[,i])\n      profile_j <- c(adj_mat[j,], adj_mat[,j])\n      dist_mat[i,j] <- sqrt(sum((profile_i - profile_j)^2))\n    }\n  }\n  \n  rownames(dist_mat) <- colnames(dist_mat) <- rownames(adj_mat)\n  return(dist_mat)\n}\n\neuclid_dist <- compute_euclidean_dist(advice_mat)\n\n# Display distance matrix\nround(euclid_dist, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      M1   M2   M3   M4   M5   M6   M7   M8   M9  M10\nM1  0.00 2.65 2.83 2.65 2.65 2.65 3.00 3.00 2.45 2.45\nM2  2.65 0.00 2.65 2.45 1.41 1.41 2.45 2.45 2.65 2.65\nM3  2.83 2.65 0.00 1.00 2.24 2.65 3.00 3.00 2.45 2.45\nM4  2.65 2.45 1.00 0.00 2.00 2.45 2.83 2.83 2.24 2.24\nM5  2.65 1.41 2.24 2.00 0.00 1.41 2.45 2.45 2.65 2.65\nM6  2.65 1.41 2.65 2.45 1.41 0.00 2.00 2.00 2.65 2.65\nM7  3.00 2.45 3.00 2.83 2.45 2.00 0.00 2.00 3.00 3.00\nM8  3.00 2.45 3.00 2.83 2.45 2.00 2.00 0.00 3.00 3.00\nM9  2.45 2.65 2.45 2.24 2.65 2.65 3.00 3.00 0.00 2.00\nM10 2.45 2.65 2.45 2.24 2.65 2.65 3.00 3.00 2.00 0.00\n```\n\n\n:::\n:::\n\n\n## Visualizing Equivalence with Heatmap\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create heatmap of structural equivalence\nif (use_pheatmap) {\n  pheatmap::pheatmap(similarity_matrix,\n           cluster_rows = TRUE,\n           cluster_cols = TRUE,\n           display_numbers = TRUE,\n           number_format = \"%.2f\",\n           main = \"Structural Equivalence Similarity\\n(Correlation-based)\",\n           color = colorRampPalette(c(\"white\", \"lightblue\", \"darkblue\"))(100))\n} else {\n  heatmap(similarity_matrix,\n          main = \"Structural Equivalence Similarity\\n(Correlation-based)\",\n          col = colorRampPalette(c(\"white\", \"lightblue\", \"darkblue\"))(100))\n}\n```\n\n::: {.cell-output-display}\n![](practice_3_files/figure-html/heatmap-equivalence-1.png){width=768}\n:::\n:::\n\n\n# Hierarchical Clustering\n\nWe can use hierarchical clustering to identify groups of structurally equivalent actors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert similarity to distance for clustering\n# Use 1 - correlation as distance\ndist_matrix <- as.dist(1 - similarity_matrix)\n\n# Perform hierarchical clustering\nhc <- hclust(dist_matrix, method = \"complete\")\n\n# Plot dendrogram\npar(mar = c(5, 4, 5, 2))\nplot(hc,\n     main = \"Hierarchical Clustering of Structural Equivalence\",\n     xlab = \"Managers\",\n     ylab = \"Distance\",\n     sub = \"\")\n\n# Add rectangles for 3 clusters\nrect.hclust(hc, k = 3, border = 2:4)\n```\n\n::: {.cell-output-display}\n![](practice_3_files/figure-html/hierarchical-clustering-1.png){width=960}\n:::\n:::\n\n\n## Extract Clusters\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Cut tree to get 3 positions\npositions <- cutree(hc, k = 3)\n\n# Display position assignments\ncat(\"Position assignments:\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nPosition assignments:\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(positions)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n M1  M2  M3  M4  M5  M6  M7  M8  M9 M10 \n  1   2   3   3   2   2   2   2   1   1 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Count members per position\ncat(\"\\nPosition sizes:\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nPosition sizes:\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(table(positions))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\npositions\n1 2 3 \n3 5 2 \n```\n\n\n:::\n:::\n\n\n# CONCOR Algorithm\n\n**CONCOR** (CONvergence of iterated CORrelations) is a classical algorithm specifically designed for blockmodeling. It works on a fascinating mathematical property: if you repeatedly calculate the correlation matrix of a correlation matrix, the values eventually converge to a matrix containing only +1 and -1.\n\nThis divides the actors into two distinct groups (blocks). We can then apply the procedure recursively to split these groups further, creating a hierarchical blockmodel.\n\n## Implementing CONCOR\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Perform CONCOR using custom implementation\n# Simplified CONCOR algorithm\nconcor_simple <- function(adj_mat, max_iter = 25) {\n  # Compute initial correlation matrix\n  sim_mat <- compute_structural_equiv(adj_mat)\n  \n  # Iteratively correlate\n  for(iter in 1:max_iter) {\n    old_sim <- sim_mat\n    sim_mat <- cor(sim_mat)\n    \n    # Check for convergence\n    if(max(abs(sim_mat - old_sim)) < 0.001) break\n  }\n  \n  # Convert to distance and cluster  \n  dist_mat <- as.dist(1 - sim_mat)\n  hc <- hclust(dist_mat, method = \"complete\")\n  return(hc)\n}\n\nconcor_result <- concor_simple(advice_mat)\n\n# Plot CONCOR dendrogram\npar(mar = c(5, 4, 5, 2))\nplot(concor_result,\n     main = \"CONCOR-style Blockmodel Dendrogram\")\n```\n\n::: {.cell-output-display}\n![](practice_3_files/figure-html/concor-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Get block membership (using 3 blocks)\nconcor_membership <- cutree(concor_result, k = 3)\n\ncat(\"CONCOR block assignments:\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCONCOR block assignments:\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(concor_membership)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n M1  M2  M3  M4  M5  M6  M7  M8  M9 M10 \n  1   2   3   3   2   2   2   2   1   1 \n```\n\n\n:::\n:::\n\n\n# Creating Blockmodels\n\n## Reorder Matrix by Position\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Reorder adjacency matrix by position\nblock_order <- order(positions)\nblocked_mat <- advice_mat[block_order, block_order]\n\n# Display blocked matrix\ncat(\"Reordered adjacency matrix by position:\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReordered adjacency matrix by position:\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(blocked_mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    M1 M9 M10 M2 M5 M6 M7 M8 M3 M4\nM1   0  0   0  0  0  0  0  0  1  0\nM9   0  0   1  0  0  0  0  0  1  1\nM10  0  1   0  0  0  0  0  0  1  1\nM2   0  0   0  0  0  0  0  0  0  0\nM5   1  0   0  0  0  0  0  0  0  0\nM6   0  0   0  1  0  0  0  0  0  0\nM7   0  0   0  1  1  1  0  1  0  0\nM8   0  0   0  1  1  1  1  0  0  0\nM3   1  0   0  0  0  0  0  0  0  0\nM4   1  0   0  0  0  0  0  0  0  0\n```\n\n\n:::\n:::\n\n\n## Visualize Blocked Matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create heatmap of blocked adjacency matrix\nif (use_pheatmap) {\n  pheatmap::pheatmap(blocked_mat,\n           cluster_rows = FALSE,\n           cluster_cols = FALSE,\n           display_numbers = TRUE,\n           number_format = \"%.0f\",\n           main = \"Blocked Adjacency Matrix\",\n           color = colorRampPalette(c(\"white\", \"coral\"))(2),\n           legend = FALSE)\n} else {\n  heatmap(blocked_mat, \n          Rowv = NA, Colv = NA,\n          main = \"Blocked Adjacency Matrix\",\n          col = c(\"white\", \"coral\"),\n          scale = \"none\")\n}\n```\n\n::: {.cell-output-display}\n![](practice_3_files/figure-html/viz-blocked-matrix-1.png){width=768}\n:::\n:::\n\n\n# Image Matrices\n\nAn **image matrix** is a simplified representation of the network. Instead of showing ties between individual actors, it shows ties between *positions* (blocks).\n\nTo create it, we calculate the density of ties between every pair of positions. If the density is above a certain threshold (often the overall network density or a specific `alpha` value), we say there is a '1-block' (a tie between positions). Otherwise, it is a '0-block'.\n\n## Compute Image Matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to create image matrix\ncreate_image_matrix <- function(adj_matrix, positions, alpha = 0.5) {\n  n_positions <- max(positions)\n  image_mat <- matrix(0, nrow = n_positions, ncol = n_positions)\n  \n  for(i in 1:n_positions) {\n    for(j in 1:n_positions) {\n      # Get actors in positions i and j\n      actors_i <- which(positions == i)\n      actors_j <- which(positions == j)\n      \n      # Extract block\n      block <- adj_matrix[actors_i, actors_j, drop = FALSE]\n      \n      # Calculate density\n      block_density <- sum(block) / length(block)\n      \n      # Set image based on alpha threshold\n      image_mat[i, j] <- ifelse(block_density >= alpha, 1, 0)\n    }\n  }\n  \n  rownames(image_mat) <- colnames(image_mat) <- paste0(\"Pos\", 1:n_positions)\n  return(image_mat)\n}\n\n# Create image matrix with alpha = 0.5\nimage_mat <- create_image_matrix(advice_mat, positions, alpha = 0.5)\n\ncat(\"Image matrix (alpha = 0.5):\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nImage matrix (alpha = 0.5):\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(image_mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Pos1 Pos2 Pos3\nPos1    0    0    1\nPos2    0    0    0\nPos3    0    0    0\n```\n\n\n:::\n:::\n\n\n## Visualize Image Matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Visualize image matrix\nif (use_pheatmap) {\n  pheatmap::pheatmap(image_mat,\n           cluster_rows = FALSE,\n           cluster_cols = FALSE,\n           display_numbers = TRUE,\n           number_format = \"%.0f\",\n           main = \"Image Matrix\\n(Reduced Network)\",\n           color = colorRampPalette(c(\"white\", \"darkred\"))(2),\n           legend = FALSE)\n} else {\n  heatmap(image_mat,\n          Rowv = NA, Colv = NA,\n          main = \"Image Matrix\\n(Reduced Network)\",\n          col = c(\"white\", \"darkred\"),\n          scale = \"none\")\n}\n```\n\n::: {.cell-output-display}\n![](practice_3_files/figure-html/viz-image-matrix-1.png){width=576}\n:::\n:::\n\n\n## Plot Reduced Network\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create network from image matrix\nimage_net <- graph_from_adjacency_matrix(image_mat, mode = \"directed\")\n\n# Set vertex names\nV(image_net)$name <- paste0(\"Pos\", 1:vcount(image_net))\n\n# Plot reduced network\nset.seed(42)\n# Set margins to ensure title is within bounding box\npar(mar = c(1, 1, 4, 1))\nplot(image_net,\n     layout = layout_nicely(image_net),\n     vertex.color = c(\"coral\", \"lightblue\", \"lightgreen\")[1:vcount(image_net)],\n     vertex.size = 40,\n     vertex.label = V(image_net)$name,\n     vertex.label.cex = 1.2,\n     vertex.label.color = \"white\",\n     edge.color = \"black\",\n     edge.width = 3,\n     edge.arrow.size = 0.8,\n     main = \"Reduced Network (Image Graph)\")\n```\n\n::: {.cell-output-display}\n![](practice_3_files/figure-html/plot-reduced-network-1.png){width=576}\n:::\n:::\n\n\n# Block Density Analysis\n\nAnalyze within-block and between-block densities to assess blockmodel quality.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to compute block density table\ncompute_block_densities <- function(adj_matrix, positions) {\n  n_positions <- max(positions)\n  density_mat <- matrix(0, nrow = n_positions, ncol = n_positions)\n  \n  for(i in 1:n_positions) {\n    for(j in 1:n_positions) {\n      actors_i <- which(positions == i)\n      actors_j <- which(positions == j)\n      \n      block <- adj_matrix[actors_i, actors_j, drop = FALSE]\n      density_mat[i, j] <- sum(block) / length(block)\n    }\n  }\n  \n  rownames(density_mat) <- colnames(density_mat) <- paste0(\"Pos\", 1:n_positions)\n  return(density_mat)\n}\n\n# Compute block densities\nblock_densities <- compute_block_densities(advice_mat, positions)\n\ncat(\"Block densities:\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nBlock densities:\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(round(block_densities, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Pos1 Pos2  Pos3\nPos1 0.222 0.00 0.833\nPos2 0.067 0.36 0.000\nPos3 0.333 0.00 0.000\n```\n\n\n:::\n\n```{.r .cell-code}\n# Visualize block densities\nif (use_pheatmap) {\n  pheatmap::pheatmap(block_densities,\n           cluster_rows = FALSE,\n           cluster_cols = FALSE,\n           display_numbers = TRUE,\n           number_format = \"%.2f\",\n           main = \"Block Densities\",\n           color = colorRampPalette(c(\"white\", \"orange\", \"darkred\"))(100))\n} else {\n  heatmap(block_densities,\n          Rowv = NA, Colv = NA,\n          main = \"Block Densities\",\n          col = colorRampPalette(c(\"white\", \"orange\", \"darkred\"))(100),\n          scale = \"none\")\n}\n```\n\n::: {.cell-output-display}\n![](practice_3_files/figure-html/block-density-1.png){width=672}\n:::\n:::\n\n\n# Assessing Blockmodel Fit\n\n## Blockmodel Adequacy\n\nWe can measure how well the blockmodel represents the original network using correlation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Reconstruct network from blockmodel\nreconstruct_from_blocks <- function(image_mat, positions) {\n  n <- length(positions)\n  recon_mat <- matrix(0, nrow = n, ncol = n)\n  \n  for(i in 1:n) {\n    for(j in 1:n) {\n      pos_i <- positions[i]\n      pos_j <- positions[j]\n      recon_mat[i, j] <- image_mat[pos_i, pos_j]\n    }\n  }\n  \n  return(recon_mat)\n}\n\n# Reconstruct\nreconstructed <- reconstruct_from_blocks(image_mat, positions)\n\n# Compute correlation between original and reconstructed\nfit_cor <- cor(as.vector(advice_mat), as.vector(reconstructed))\n\ncat(\"Blockmodel fit (correlation):\", round(fit_cor, 3), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nBlockmodel fit (correlation): 0.414 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Compute accuracy\nmatching <- sum((advice_mat > 0) == (reconstructed > 0))\ntotal <- length(advice_mat)\naccuracy <- matching / total\n\ncat(\"Classification accuracy:\", round(accuracy, 3), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nClassification accuracy: 0.85 \n```\n\n\n:::\n:::\n\n\n# Example 2: Larger Network - Classic Blockmodel Study\n\nLet's use a larger, well-known dataset to demonstrate blockmodeling at scale.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a stylized larger network with clearer role structure\n# Simulating an organization with distinct hierarchical positions\n\nn_senior <- 2\nn_middle <- 4\nn_junior <- 8\nn_total <- n_senior + n_middle + n_junior\n\n# Initialize matrix\norg_mat <- matrix(0, nrow = n_total, ncol = n_total)\nrownames(org_mat) <- colnames(org_mat) <- paste0(\"E\", 1:n_total)\n\n# Define position indices\nsenior_idx <- 1:n_senior\nmiddle_idx <- (n_senior + 1):(n_senior + n_middle)\njunior_idx <- (n_senior + n_middle + 1):n_total\n\n# Add ties based on organizational hierarchy\n# Juniors -> Middle managers (high density)\nfor(j in junior_idx) {\n  contacts <- sample(middle_idx, size = 2)\n  org_mat[j, contacts] <- 1\n}\n\n# Middle -> Seniors (high density)\nfor(m in middle_idx) {\n  contacts <- sample(senior_idx, size = 1)\n  org_mat[m, contacts] <- 1\n}\n\n# Seniors -> Middle (moderate density, delegation)\nfor(s in senior_idx) {\n  contacts <- sample(middle_idx, size = 2)\n  org_mat[s, contacts] <- 1\n}\n\n# Some peer connections within levels\n# Junior peers\nfor(i in 1:3) {\n  pair <- sample(junior_idx, 2)\n  org_mat[pair[1], pair[2]] <- 1\n}\n\n# Middle peers\nfor(i in 1:2) {\n  pair <- sample(middle_idx, 2)\n  org_mat[pair[1], pair[2]] <- 1\n}\n\n# Create network\norg_net <- graph_from_adjacency_matrix(org_mat, mode = \"directed\")\n\ncat(\"Organization network:\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nOrganization network:\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Nodes:\", vcount(org_net), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNodes: 14 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Edges:\", ecount(org_net), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nEdges: 29 \n```\n\n\n:::\n:::\n\n\n## Visualize Organization Network\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assign colors by true position\ntrue_positions <- c(rep(1, n_senior), rep(2, n_middle), rep(3, n_junior))\ncolors <- c(\"darkred\", \"orange\", \"lightblue\")[true_positions]\n\nset.seed(42)\nlayout_org <- layout_with_fr(org_net)\n\n# Set margins to ensure title is within bounding box\npar(mar = c(1, 1, 4, 1))\nplot(org_net,\n     layout = layout_org,\n     vertex.color = colors,\n     vertex.size = 15,\n     vertex.label = V(org_net)$name,\n     vertex.label.cex = 0.7,\n     edge.color = \"gray60\",\n     edge.arrow.size = 0.5,\n     main = \"Organizational Hierarchy Network\")\n\nlegend(\"bottomright\", \n       legend = c(\"Senior\", \"Middle\", \"Junior\"),\n       col = c(\"darkred\", \"orange\", \"lightblue\"),\n       pch = 19,\n       pt.cex = 2,\n       bty = \"n\")\n```\n\n::: {.cell-output-display}\n![](practice_3_files/figure-html/viz-org-network-1.png){width=960}\n:::\n:::\n\n\n## Apply Blockmodeling\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute structural equivalence\norg_similarity <- compute_structural_equiv(org_mat)\norg_equiv <- 1 - org_similarity  # Convert to distance\n\n# Hierarchical clustering\norg_hc <- hclust(as.dist(org_equiv), method = \"complete\")\n\n# Cut for 3 positions\norg_positions <- cutree(org_hc, k = 3)\n\ncat(\"Discovered positions:\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDiscovered positions:\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(org_positions)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n E1  E2  E3  E4  E5  E6  E7  E8  E9 E10 E11 E12 E13 E14 \n  1   2   3   3   3   1   1   2   1   2   1   1   1   1 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Dendrogram\npar(mar = c(5, 4, 5, 2))\nplot(org_hc,\n     main = \"Organizational Network - Hierarchical Clustering\",\n     xlab = \"Employees\",\n     labels = rownames(org_mat))\nrect.hclust(org_hc, k = 3, border = 2:4)\n```\n\n::: {.cell-output-display}\n![](practice_3_files/figure-html/org-blockmodel-1.png){width=672}\n:::\n:::\n\n\n## Organization Image Matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create image matrix\norg_image <- create_image_matrix(org_mat, org_positions, alpha = 0.3)\n\ncat(\"Organization image matrix:\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nOrganization image matrix:\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(org_image)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Pos1 Pos2 Pos3\nPos1    0    0    1\nPos2    0    0    1\nPos3    0    0    0\n```\n\n\n:::\n\n```{.r .cell-code}\n# Visualize\nif (use_pheatmap) {\n  pheatmap::pheatmap(org_image,\n           cluster_rows = FALSE,\n           cluster_cols = FALSE,\n           display_numbers = TRUE,\n           number_format = \"%.0f\",\n           main = \"Organization Image Matrix\",\n           color = colorRampPalette(c(\"white\", \"navy\"))(2),\n           legend = FALSE)\n} else {\n  heatmap(org_image,\n          Rowv = NA, Colv = NA,\n          main = \"Organization Image Matrix\",\n          col = c(\"white\", \"navy\"),\n          scale = \"none\")\n}\n```\n\n::: {.cell-output-display}\n![](practice_3_files/figure-html/org-image-matrix-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Block densities\norg_densities <- compute_block_densities(org_mat, org_positions)\n\ncat(\"\\nBlock densities:\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nBlock densities:\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(round(org_densities, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Pos1  Pos2  Pos3\nPos1 0.062 0.042 0.542\nPos2 0.000 0.000 0.667\nPos3 0.083 0.111 0.222\n```\n\n\n:::\n:::\n\n\n# Comparing Position Detection Methods\n\nLet's compare different methods for identifying positions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Method 1: Hierarchical clustering with correlation\nmethod1 <- cutree(hclust(as.dist(1 - compute_structural_equiv(advice_mat)),\n                         method = \"complete\"), k = 3)\n\n# Method 2: Hierarchical clustering with Euclidean distance\nmethod2 <- cutree(hclust(as.dist(compute_euclidean_dist(advice_mat)),\n                         method = \"ward.D2\"), k = 3)\n\n# Method 3: CONCOR\nmethod3 <- cutree(concor_simple(advice_mat), k = 3)\n\n# Compare assignments\ncomparison <- data.frame(\n  Actor = rownames(advice_mat),\n  Correlation_HC = method1,\n  Euclidean_HC = method2,\n  CONCOR = method3\n)\n\nprint(comparison)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Actor Correlation_HC Euclidean_HC CONCOR\nM1     M1              1            1      1\nM2     M2              2            2      2\nM3     M3              3            3      3\nM4     M4              3            3      3\nM5     M5              2            2      2\nM6     M6              2            2      2\nM7     M7              2            2      2\nM8     M8              2            2      2\nM9     M9              1            1      1\nM10   M10              1            1      1\n```\n\n\n:::\n\n```{.r .cell-code}\n# Calculate agreement between methods\ncat(\"\\nAgreement between methods:\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nAgreement between methods:\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Correlation vs Euclidean:\", \n    sum(method1 == method2) / length(method1), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCorrelation vs Euclidean: 1 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Correlation vs CONCOR:\", \n    sum(method1 == method3) / length(method1), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCorrelation vs CONCOR: 1 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Euclidean vs CONCOR:\", \n    sum(method2 == method3) / length(method2), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nEuclidean vs CONCOR: 1 \n```\n\n\n:::\n:::\n\n\n# Interpretation and Substantive Meaning\n\nWhen interpreting blockmodels, consider the **Image Matrix** and the **Block Densities**:\n\n1.  **Reflexive ties (diagonal)**: A '1' on the diagonal (e.g., Pos1 -> Pos1) means the position is internally cohesive (like a community).\n2.  **Asymmetric ties**: A '1' from Pos1 -> Pos2 but '0' from Pos2 -> Pos1 suggests a hierarchy or flow (e.g., advice seeking).\n3.  **Isolates**: A position with '0's everywhere suggests isolated actors.\n4.  **Core-Periphery**: A core position connects to itself and others; a periphery position connects only to the core.\n\n## Role Interpretation\n\nBased on our advice network analysis:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Analyze each position's characteristics\nfor(pos in 1:3) {\n  cat(\"\\n=== Position\", pos, \"===\\n\")\n  members <- which(positions == pos)\n  cat(\"Members:\", paste(names(members), collapse = \", \"), \"\\n\")\n  \n  # Out-degree (advice giving)\n  out_deg <- rowSums(advice_mat[members, , drop = FALSE])\n  cat(\"Avg out-degree:\", round(mean(out_deg), 2), \"\\n\")\n  \n  # In-degree (advice seeking)\n  in_deg <- colSums(advice_mat[, members, drop = FALSE])\n  cat(\"Avg in-degree:\", round(mean(in_deg), 2), \"\\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n=== Position 1 ===\nMembers: M1, M9, M10 \nAvg out-degree: 2.33 \nAvg in-degree: 1.67 \n\n=== Position 2 ===\nMembers: M2, M5, M6, M7, M8 \nAvg out-degree: 2 \nAvg in-degree: 1.8 \n\n=== Position 3 ===\nMembers: M3, M4 \nAvg out-degree: 1 \nAvg in-degree: 2.5 \n```\n\n\n:::\n:::\n\n\n::: {.callout-tip}\n## Interpreting Positions\n\n- **Position 1**: High in-degree, low out-degree → **Advice Givers** (senior experts)\n- **Position 2**: Moderate both → **Intermediaries** (middle management)  \n- **Position 3**: Low in-degree, high out-degree → **Advice Seekers** (juniors)\n:::\n\n# Key Takeaways\n\n1. **Structural equivalence** identifies actors with similar tie patterns, revealing role structures\n\n2. **Multiple measurement approaches** exist (correlation, Euclidean, etc.) - compare results\n\n3. **CONCOR** is a classical algorithm but hierarchical clustering offers more flexibility\n\n4. **Image matrices** provide reduced representations of complex networks\n\n5. **Blockmodel fit** should be assessed - not all networks have clear role structures\n\n6. **Substantive interpretation** is crucial - positions should make sense in context\n\n7. **Position != Community** - positions are about similar patterns, not cohesion\n\n# Exercises\n\n## Exercise 1: Apply to Karate Club\n\nLoad Zachary's Karate Club network and:\n\n1. Compute structural equivalence between members\n2. Identify positions using hierarchical clustering\n3. Create and interpret the image matrix\n4. Do positions correspond to the known split?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Starter code\nlibrary(igraph)\nkarate <- make_graph(\"Zachary\")\nkarate_mat <- as_adjacency_matrix(karate, sparse = FALSE)\n\n# Your code here\n```\n:::\n\n\n## Exercise 2: Different Alpha Values\n\nFor the advice network:\n\n1. Create image matrices with alpha = 0.25, 0.5, 0.75\n2. Compare the resulting image graphs\n3. Which alpha best represents the network?\n\n## Exercise 3: Regular Equivalence (Advanced)\n\nResearch and implement a measure of regular equivalence (e.g., using the `REGE` algorithm or `equiv.clust` from the `sna` package):\n\n1. Understand the difference from structural equivalence\n2. Apply to the advice network\n3. Compare results with structural equivalence\n4. When would regular equivalence be more appropriate?\n\n# Additional Resources\n\n- **Foundational paper**: White, Boorman, & Breiger (1976). Social structure from multiple networks.\n\n- **sna package documentation**: [CRAN sna reference](https://CRAN.R-project.org/package=sna)\n\n- **Blockmodeling book**: Doreian, Batagelj, & Ferligoj (2005). *Generalized Blockmodeling*\n\n- **Applied examples**: Wasserman & Faust (1994), Chapters 9-10\n\n---\n\n**Next Steps**: Try combining community detection (from `practice_1.qmd`) with role analysis. Do structurally equivalent actors belong to the same communities? Often they don't—community detection finds cohesive groups (friends), while role analysis finds similar types of people (e.g., all the \"popular kids\" might not be friends with each other, but they occupy the same role).\n",
    "supporting": [
      "practice_3_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
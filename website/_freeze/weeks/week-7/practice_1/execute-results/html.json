{
  "hash": "1d8186b1f1912303f863f46a2c3ddcf7",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Community Detection in R\"\nsubtitle: \"Identifying cohesive subgroups in networks\"\nformat: \n  html:\n    code-fold: false\n    toc: true\n    toc-depth: 3\n    number-sections: true\nexecute:\n  warning: false\n  message: false\n---\n\n# Introduction\n\nThis tutorial demonstrates how to detect and analyze communities in networks using R. We'll explore multiple algorithms, compare their results, and learn how to assess community structure quality.\n\n## Learning Objectives\n\nBy the end of this tutorial, you will be able to:\n\n- Implement multiple community detection algorithms in R\n- Calculate and interpret modularity scores\n- Compare community detection methods\n- Visualize community structure\n- Assess the quality and robustness of detected communities\n\n## Required Packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load required packages\nlibrary(igraph)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(patchwork)\n\n# Set seed for reproducibility\nset.seed(42)\n```\n:::\n\n\n# Loading and Exploring Network Data\n\n## Example 1: Karate Club Network\n\nWe'll start with the classic Zachary's Karate Club network - a well-studied network documenting social interactions in a karate club that eventually split into two groups.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the karate club network\nkarate <- make_graph(\"Zachary\")\n\n# Basic network statistics\ncat(\"Network size:\", vcount(karate), \"nodes\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNetwork size: 34 nodes\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Network edges:\", ecount(karate), \"edges\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNetwork edges: 78 edges\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Network density:\", edge_density(karate), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNetwork density: 0.1390374 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Average clustering:\", transitivity(karate, type = \"average\"), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAverage clustering: 0.5879306 \n```\n\n\n:::\n:::\n\n\n## Visualizing the Original Network\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set layout for consistent visualization\nset.seed(42)\nlayout_karate <- layout_with_fr(karate)\n\n# Plot the network\nplot(karate,\n     layout = layout_karate,\n     vertex.size = 10,\n     vertex.label.cex = 0.7,\n     vertex.color = \"lightblue\",\n     vertex.frame.color = \"darkblue\",\n     edge.color = \"gray80\",\n     main = \"Zachary's Karate Club Network\")\n```\n\n::: {.cell-output-display}\n![](practice_1_files/figure-html/viz-original-1.png){width=768}\n:::\n:::\n\n\n# Community Detection Algorithms\n\n## Method 1: Louvain Algorithm\n\nThe Louvain algorithm is a fast, hierarchical method that maximizes modularity.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Detect communities using Louvain\nlouvain_comm <- cluster_louvain(karate)\n\n# Summary statistics\ncat(\"Number of communities:\", length(louvain_comm), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNumber of communities: 4 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Modularity:\", modularity(louvain_comm), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModularity: 0.4197896 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Community sizes:\", sizes(louvain_comm), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCommunity sizes: 11 5 12 6 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Community membership\nprint(membership(louvain_comm))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1 1 1 1 2 2 2 1 3 3 2 1 1 1 3 3 2 1 3 1 3 1 3 4 4 4 3 4 4 3 3 4 3 3\n```\n\n\n:::\n:::\n\n\n### Visualizing Louvain Communities\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define colors for communities\ncolors <- c(\"coral\", \"lightblue\", \"lightgreen\", \"gold\", \"plum\")\n\nplot(louvain_comm, karate,\n     layout = layout_karate,\n     vertex.size = 10,\n     vertex.label.cex = 0.7,\n     edge.color = \"gray80\",\n     main = paste0(\"Louvain Algorithm\\nModularity = \", \n                   round(modularity(louvain_comm), 3)))\n```\n\n::: {.cell-output-display}\n![](practice_1_files/figure-html/viz-louvain-1.png){width=768}\n:::\n:::\n\n\n## Method 2: Edge Betweenness\n\nThe edge betweenness algorithm identifies communities by removing edges with high betweenness.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Detect communities using edge betweenness\neb_comm <- cluster_edge_betweenness(karate)\n\ncat(\"Number of communities:\", length(eb_comm), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNumber of communities: 5 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Modularity:\", modularity(eb_comm), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModularity: 0.4012985 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Community sizes:\", sizes(eb_comm), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCommunity sizes: 10 6 5 12 1 \n```\n\n\n:::\n:::\n\n\n### Visualizing Edge Betweenness Communities\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(eb_comm, karate,\n     layout = layout_karate,\n     vertex.size = 10,\n     vertex.label.cex = 0.7,\n     edge.color = \"gray80\",\n     main = paste0(\"Edge Betweenness Algorithm\\nModularity = \", \n                   round(modularity(eb_comm), 3)))\n```\n\n::: {.cell-output-display}\n![](practice_1_files/figure-html/viz-edge-betweenness-1.png){width=768}\n:::\n:::\n\n\n## Method 3: Walktrap\n\nThe walktrap algorithm uses random walks to identify communities.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Detect communities using walktrap\nwalktrap_comm <- cluster_walktrap(karate)\n\ncat(\"Number of communities:\", length(walktrap_comm), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNumber of communities: 5 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Modularity:\", modularity(walktrap_comm), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModularity: 0.3532216 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Community sizes:\", sizes(walktrap_comm), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCommunity sizes: 9 7 9 4 5 \n```\n\n\n:::\n:::\n\n\n### Visualizing Walktrap Communities\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(walktrap_comm, karate,\n     layout = layout_karate,\n     vertex.size = 10,\n     vertex.label.cex = 0.7,\n     edge.color = \"gray80\",\n     main = paste0(\"Walktrap Algorithm\\nModularity = \", \n                   round(modularity(walktrap_comm), 3)))\n```\n\n::: {.cell-output-display}\n![](practice_1_files/figure-html/viz-walktrap-1.png){width=768}\n:::\n:::\n\n\n## Method 4: Leading Eigenvector (Spectral)\n\nThis method uses the leading eigenvector of the modularity matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Detect communities using leading eigenvector\nspectral_comm <- cluster_leading_eigen(karate)\n\ncat(\"Number of communities:\", length(spectral_comm), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNumber of communities: 4 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Modularity:\", modularity(spectral_comm), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModularity: 0.3934089 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Community sizes:\", sizes(spectral_comm), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCommunity sizes: 7 12 9 6 \n```\n\n\n:::\n:::\n\n\n### Visualizing Spectral Communities\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(spectral_comm, karate,\n     layout = layout_karate,\n     vertex.size = 10,\n     vertex.label.cex = 0.7,\n     edge.color = \"gray80\",\n     main = paste0(\"Spectral Method\\nModularity = \", \n                   round(modularity(spectral_comm), 3)))\n```\n\n::: {.cell-output-display}\n![](practice_1_files/figure-html/viz-spectral-1.png){width=768}\n:::\n:::\n\n\n## Method 5: Fast Greedy\n\nA hierarchical agglomerative algorithm that's fast for large networks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Detect communities using fast greedy\nfg_comm <- cluster_fast_greedy(karate)\n\ncat(\"Number of communities:\", length(fg_comm), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNumber of communities: 3 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Modularity:\", modularity(fg_comm), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModularity: 0.3806706 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Community sizes:\", sizes(fg_comm), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCommunity sizes: 8 17 9 \n```\n\n\n:::\n:::\n\n\n# Comparing Methods\n\n## Summary Comparison Table\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create comparison data frame\ncomparison <- data.frame(\n  Method = c(\"Louvain\", \"Edge Betweenness\", \"Walktrap\", \n             \"Spectral\", \"Fast Greedy\"),\n  Communities = c(length(louvain_comm), length(eb_comm), \n                  length(walktrap_comm), length(spectral_comm), \n                  length(fg_comm)),\n  Modularity = c(modularity(louvain_comm), modularity(eb_comm),\n                 modularity(walktrap_comm), modularity(spectral_comm),\n                 modularity(fg_comm))\n)\n\n# Display table\nknitr::kable(comparison, \n             digits = 4,\n             caption = \"Comparison of Community Detection Methods\")\n```\n\n::: {.cell-output-display}\n\n\nTable: Comparison of Community Detection Methods\n\n|Method           | Communities| Modularity|\n|:----------------|-----------:|----------:|\n|Louvain          |           4|     0.4198|\n|Edge Betweenness |           5|     0.4013|\n|Walktrap         |           5|     0.3532|\n|Spectral         |           4|     0.3934|\n|Fast Greedy      |           3|     0.3807|\n\n\n:::\n:::\n\n\n## Modularity Comparison Plot\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(comparison, aes(x = reorder(Method, Modularity), y = Modularity)) +\n  geom_col(fill = \"steelblue\", alpha = 0.8) +\n  geom_text(aes(label = round(Modularity, 3)), \n            vjust = -0.5, size = 4) +\n  coord_flip() +\n  labs(title = \"Modularity Scores by Community Detection Method\",\n       x = \"Method\",\n       y = \"Modularity\") +\n  theme_minimal() +\n  theme(plot.title = element_text(face = \"bold\", size = 14))\n```\n\n::: {.cell-output-display}\n![](practice_1_files/figure-html/modularity-plot-1.png){width=768}\n:::\n:::\n\n\n## Agreement Between Methods\n\nCalculate how similar the community assignments are across methods.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to calculate normalized mutual information\ncalculate_nmi <- function(comm1, comm2) {\n  compare(comm1, comm2, method = \"nmi\")\n}\n\n# Create agreement matrix\nmethods_list <- list(\n  Louvain = louvain_comm,\n  EdgeBet = eb_comm,\n  Walktrap = walktrap_comm,\n  Spectral = spectral_comm,\n  FastGreedy = fg_comm\n)\n\n# Calculate pairwise NMI\nnmi_matrix <- matrix(0, nrow = 5, ncol = 5)\nrownames(nmi_matrix) <- colnames(nmi_matrix) <- names(methods_list)\n\nfor(i in 1:5) {\n  for(j in 1:5) {\n    nmi_matrix[i,j] <- calculate_nmi(methods_list[[i]], methods_list[[j]])\n  }\n}\n\n# Display as heatmap\nlibrary(reshape2)\nnmi_long <- melt(nmi_matrix)\n\nggplot(nmi_long, aes(x = Var1, y = Var2, fill = value)) +\n  geom_tile() +\n  geom_text(aes(label = round(value, 2)), color = \"white\", size = 4) +\n  scale_fill_gradient2(low = \"blue\", mid = \"purple\", high = \"red\",\n                       midpoint = 0.5, limit = c(0, 1)) +\n  labs(title = \"Agreement Between Methods (NMI)\",\n       x = \"\", y = \"\", fill = \"NMI\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1),\n        plot.title = element_text(face = \"bold\", size = 14))\n```\n\n::: {.cell-output-display}\n![](practice_1_files/figure-html/method-agreement-1.png){width=672}\n:::\n:::\n\n\n# Assessing Community Quality\n\n## Within vs. Between Community Density\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to calculate within and between community density\nanalyze_density <- function(graph, communities) {\n  membership <- membership(communities)\n  n_comm <- max(membership)\n  \n  within_density <- numeric(n_comm)\n  \n  for(i in 1:n_comm) {\n    subgraph <- induced_subgraph(graph, which(membership == i))\n    within_density[i] <- edge_density(subgraph)\n  }\n  \n  # Calculate between community density\n  total_possible <- vcount(graph) * (vcount(graph) - 1) / 2\n  within_nodes <- sapply(1:n_comm, function(i) sum(membership == i))\n  within_possible <- sum(within_nodes * (within_nodes - 1) / 2)\n  between_possible <- total_possible - within_possible\n  \n  between_edges <- ecount(graph) - \n    sum(sapply(1:n_comm, function(i) {\n      ecount(induced_subgraph(graph, which(membership == i)))\n    }))\n  \n  between_density <- between_edges / between_possible\n  \n  list(\n    within_mean = mean(within_density),\n    within_sd = sd(within_density),\n    between = between_density,\n    ratio = mean(within_density) / between_density\n  )\n}\n\n# Analyze Louvain communities\ndensity_stats <- analyze_density(karate, louvain_comm)\n\ncat(\"Within-community density (mean):\", round(density_stats$within_mean, 3), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nWithin-community density (mean): 0.451 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Between-community density:\", round(density_stats$between, 3), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nBetween-community density: 0.051 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Ratio (within/between):\", round(density_stats$ratio, 2), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRatio (within/between): 8.91 \n```\n\n\n:::\n:::\n\n\n## Community Size Distribution\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create data frame of community sizes for all methods\nsize_data <- data.frame(\n  Method = rep(names(methods_list), sapply(methods_list, length)),\n  Size = unlist(lapply(methods_list, sizes))\n)\n\nggplot(size_data, aes(x = Method, y = Size, fill = Method)) +\n  geom_boxplot(alpha = 0.7) +\n  geom_jitter(width = 0.2, alpha = 0.5) +\n  labs(title = \"Community Size Distribution by Method\",\n       x = \"Method\",\n       y = \"Community Size\") +\n  theme_minimal() +\n  theme(legend.position = \"none\",\n        plot.title = element_text(face = \"bold\", size = 14))\n```\n\n::: {.cell-output-display}\n![](practice_1_files/figure-html/size-distribution-1.png){width=768}\n:::\n:::\n\n\n# Resolution Parameter Exploration\n\nFor algorithms that support resolution parameters (like Louvain), we can explore different levels of granularity.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sweep resolution parameter\nresolutions <- seq(0.5, 2.0, by = 0.1)\nresults <- data.frame(\n  resolution = numeric(),\n  n_communities = numeric(),\n  modularity = numeric()\n)\n\nfor(res in resolutions) {\n  comm <- cluster_louvain(karate, resolution = res)\n  results <- rbind(results, data.frame(\n    resolution = res,\n    n_communities = length(comm),\n    modularity = modularity(comm)\n  ))\n}\n\n# Create plots\np1 <- ggplot(results, aes(x = resolution, y = n_communities)) +\n  geom_line(color = \"steelblue\", size = 1.2) +\n  geom_point(color = \"steelblue\", size = 3) +\n  labs(title = \"Resolution vs Number of Communities\",\n       x = \"Resolution Parameter\",\n       y = \"Number of Communities\") +\n  theme_minimal()\n\np2 <- ggplot(results, aes(x = resolution, y = modularity)) +\n  geom_line(color = \"coral\", size = 1.2) +\n  geom_point(color = \"coral\", size = 3) +\n  labs(title = \"Resolution vs Modularity\",\n       x = \"Resolution Parameter\",\n       y = \"Modularity\") +\n  theme_minimal()\n\np1 + p2\n```\n\n::: {.cell-output-display}\n![](practice_1_files/figure-html/resolution-sweep-1.png){width=960}\n:::\n:::\n\n\n# Example 2: Larger Network (Random Scale-Free Network)\n\nLet's apply what we've learned to a larger network. We'll generate a scale-free network using the BarabÃ¡si-Albert model, which is common in many real-world networks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate a larger scale-free network\nset.seed(42)\nlarge_net <- sample_pa(n = 100, power = 1, m = 2, directed = FALSE)\n\ncat(\"Network size:\", vcount(large_net), \"nodes\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNetwork size: 100 nodes\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Network edges:\", ecount(large_net), \"edges\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNetwork edges: 197 edges\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Network density:\", round(edge_density(large_net), 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNetwork density: 0.0398 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Apply Louvain\nlarge_comm <- cluster_louvain(large_net)\n\ncat(\"\\nCommunities detected:\", length(large_comm), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCommunities detected: 8 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Modularity:\", round(modularity(large_comm), 3), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nModularity: 0.456 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Community sizes:\", sizes(large_comm), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCommunity sizes: 20 10 21 13 9 11 10 6 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Visualize\nset.seed(42)\nplot(large_comm, large_net,\n     vertex.size = 6,\n     vertex.label = NA,\n     edge.color = \"gray90\",\n     main = paste0(\"Scale-Free Network Communities (n=100)\\n\",\n                   \"Louvain Algorithm, Modularity = \", \n                   round(modularity(large_comm), 3)))\n```\n\n::: {.cell-output-display}\n![](practice_1_files/figure-html/larger-network-1.png){width=960}\n:::\n:::\n\n\n# Hierarchical Community Structure\n\nSome algorithms (like edge betweenness and fast greedy) create hierarchical dendrograms.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use fast greedy to get hierarchy\nfg_karate <- cluster_fast_greedy(karate)\n\n# Plot dendrogram\nplot(as.dendrogram(fg_karate),\n     main = \"Hierarchical Community Structure\\nFast Greedy Algorithm\",\n     xlab = \"Node\",\n     ylab = \"Merge Height\")\n```\n\n::: {.cell-output-display}\n![](practice_1_files/figure-html/dendrogram-1.png){width=960}\n:::\n:::\n\n\n# Stability Analysis\n\nTest how stable communities are to network perturbations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to assess stability\nassess_stability <- function(graph, n_iterations = 100, \n                             removal_prop = 0.1) {\n  \n  original_comm <- cluster_louvain(graph)\n  original_membership <- membership(original_comm)\n  \n  similarities <- numeric(n_iterations)\n  \n  for(i in 1:n_iterations) {\n    # Remove random edges\n    edges_to_remove <- sample(ecount(graph), \n                               size = floor(ecount(graph) * removal_prop))\n    perturbed <- delete_edges(graph, edges_to_remove)\n    \n    # Detect communities in perturbed network\n    perturbed_comm <- cluster_louvain(perturbed)\n    \n    # Calculate similarity\n    similarities[i] <- compare(original_comm, perturbed_comm, \n                               method = \"nmi\")\n  }\n  \n  similarities\n}\n\n# Run stability analysis\nstability_scores <- assess_stability(karate, n_iterations = 50)\n\ncat(\"Mean stability (NMI):\", round(mean(stability_scores), 3), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMean stability (NMI): 0.835 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"SD stability:\", round(sd(stability_scores), 3), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSD stability: 0.097 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Plot\ndata.frame(NMI = stability_scores) %>%\n  ggplot(aes(x = NMI)) +\n  geom_histogram(bins = 20, fill = \"steelblue\", alpha = 0.7) +\n  geom_vline(xintercept = mean(stability_scores), \n             color = \"red\", linetype = \"dashed\", size = 1) +\n  labs(title = \"Community Detection Stability\",\n       subtitle = \"After removing 10% of edges (50 iterations)\",\n       x = \"Normalized Mutual Information\",\n       y = \"Frequency\") +\n  theme_minimal() +\n  theme(plot.title = element_text(face = \"bold\", size = 14))\n```\n\n::: {.cell-output-display}\n![](practice_1_files/figure-html/stability-1.png){width=672}\n:::\n:::\n\n\n# Key Takeaways\n\n1. **Multiple methods exist**: Different algorithms can produce different results. Always compare multiple approaches.\n\n2. **Modularity is key**: Higher modularity generally indicates better community structure, but it's not the only metric to consider.\n\n3. **Context matters**: The \"best\" method depends on your network properties and research questions.\n\n4. **Resolution matters**: Many algorithms have parameters that control the granularity of detected communities.\n\n5. **Stability is important**: Test how robust your communities are to perturbations.\n\n6. **Visual inspection helps**: Always visualize your communities to ensure they make substantive sense.\n\n# Exercises\n\n## Exercise 1: Compare Methods on Your Own Data\n\nLoad a network dataset of your choice and:\n\n1. Apply at least three different community detection methods\n2. Compare their modularity scores\n3. Visualize the results\n4. Assess agreement between methods using NMI\n\n## Exercise 2: Resolution Exploration\n\nUsing the Louvain algorithm:\n\n1. Sweep the resolution parameter from 0.3 to 2.5\n2. Create a plot showing how the number of communities changes\n3. Identify the \"elbow point\" where adding resolution stops being useful\n\n## Exercise 3: Community Characteristics\n\nFor the best community structure you find:\n\n1. Calculate within vs. between community density\n2. Identify which nodes are \"bridges\" between communities\n3. Examine node-level attributes (if available) to see if communities correspond to meaningful groups\n\n# Additional Resources\n\n- **igraph documentation**: [Community detection reference](https://igraph.org/r/doc/communities.html)\n- **Modularity paper**: Newman & Girvan (2004), *Physical Review E*\n- **Louvain algorithm**: Blondel et al. (2008), *Journal of Statistical Mechanics*\n- **Comparison of methods**: Fortunato (2010), *Physics Reports*\n\n---\n\n**Next Steps**: After mastering community detection, proceed to `practice_2.qmd` to learn about blockmodeling and role analysis.\n",
    "supporting": [
      "practice_1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
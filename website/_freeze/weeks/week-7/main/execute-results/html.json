{
  "hash": "d655a6051b2875679783cd62e47decf6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Week 7\"\nformat: html\nsubtitle: \"Communities, Roles, and Positions in Networks\"\ndate: \"today\"\ncallout-appearance: \"default\"\n---\n\n## Overview\n\nThis week shifts focus from individual nodes and local structures to\nunderstanding networks at a higher level of abstraction. We explore two\ncomplementary approaches to seeing social structure:\n\n1. **Connectionist approaches**: How cohesive communities form through direct\n   ties and resource flows\n2. **Positional approaches**: How roles and positions emerge through similar\n   patterns of ties\n\nThese perspectives help us address fundamental questions about social\nintegration: What holds groups together? How do we identify meaningful\nsubgroups? How do role structures organize social life?\n\n## Prepare\n\n::: {.callout-note}\n## üìö\n\nüìñ Review the [syllabus](../../course/syllabus.qmd)\n\nüìñ Review concepts from previous weeks:\n\n- [Network fundamentals](../week-1/network_terms.qmd) (Week 1)\n- [Centrality measures](../week-3/slideshow.html) (Week 3) \n- [Triadic structures](../week-4/slideshow.html) (Week 4)\n\nüìñ **Required readings** - Book chapters available in this directory:\n\nChapter 8: \"Cohesion and Groups\" and  Chapter 10: \"Positions and Roles\" from\nRawlings, Craig M., Jeffrey A. Smith, James Moody, and Daniel A. McFarland.\n[Network analysis: integrating social network theory, method, and application\nwith R](https://go.exlibris.link/5r30tSdj). Cambridge University Press, 2023.\n\n:::\n\n## Participate\n\n::: {.callout-note}\n## üë•\n\nüìâ Slideshow: [Communities, Roles, and Positions](slideshow.html)\n\n**Key topics covered**:\n\n**Theoretical Foundations**:\n- Durkheim's mechanical vs. organic solidarity\n- Granovetter's strength of weak ties\n- Watts-Strogatz small-world networks\n- Homophily and social integration\n\n**Part I: Network Communities**\n\n- Social cohesion and integration\n- Measuring connectivity: density, clustering, path lengths\n- Small-world networks and the strength of weak ties\n- **Understanding modularity**: formula, interpretation, thresholds\n- Community detection algorithms:\n  - Louvain and Leiden (modularity-based)\n  - Walktrap (random walk-based)\n  - Edge betweenness (Girvan-Newman)\n  - Label propagation\n- **Algorithm comparison**: when to use each method\n- **Resolution parameter**: controlling community granularity\n- Assessing community structure and fit\n\n**Part II: Roles and Positions**\n\n- From actors to roles: the dramaturgical metaphor\n- **Types of structural equivalence**: structural, regular, automorphic\n- **Measuring equivalence**: correlation and distance methods\n- Blockmodeling procedures and image matrices\n- **CONCOR algorithm**: convergence of iterated correlations\n- Hierarchical cluster analysis\n- Multi-relational role structures\n- Ideal role types and assessing fit\n\n**Integration: Communities ‚â† Positions**\n\n- Comparing connectionist and positional approaches\n- When partitions align vs. diverge\n- Adjusted Rand Index for measuring overlap\n- Methodological pluralism\n\n:::\n\n\n## Practice\n\n\n::: {.callout-note}\n## üíª\n\n### Tutorial 1: [Community Detection in R](practice_1.qmd)\n\nA comprehensive tutorial covering:\n\n- **Multiple algorithms**: Louvain, Edge Betweenness, Walktrap, Spectral, Fast Greedy\n- **Method comparison**: Calculate and compare modularity scores across methods\n- **Agreement analysis**: Use Normalized Mutual Information (NMI) to assess method consistency\n- **Quality assessment**: Analyze within vs. between community density\n- **Resolution exploration**: Sweep resolution parameters to find optimal granularity\n- **Stability testing**: Assess robustness to network perturbations\n- **Visualization**: Create publication-quality community structure plots\n- **Hands-on examples**: Karate Club network and scale-free networks\n\n### Tutorial 2: [Community Detection in Python](practice_2.qmd)\n\nA parallel tutorial using Python and NetworkX that demonstrates:\n\n- Loading and exploring networks in Python\n- Applying greedy modularity, label propagation, and Girvan-Newman algorithms\n- Optionally running Louvain (if `python-louvain` is installed)\n- Computing modularity using `networkx.algorithms.community`\n- Visualizing communities with Matplotlib\n- Comparing methods via a modularity summary table and bar plot\n- Applying methods to both the karate club graph and a larger scale-free network\n\n### Tutorial 3: [Role and Position Analysis in R](practice_3.qmd)\n\nA comprehensive tutorial covering blockmodeling and structural equivalence:\n\n- **Structural equivalence measures**: Correlation and Euclidean distance\n- **CONCOR algorithm**: Classical blockmodeling approach\n- **Hierarchical clustering**: Identifying positions from tie profiles\n- **Blockmodels and image matrices**: Reduced network representations\n- **Block density analysis**: Within vs. between position densities\n- **Multiple methods comparison**: Comparing different equivalence measures\n- **Model fit assessment**: Evaluating blockmodel quality\n- **Practical examples**: Corporate advice networks and organizational hierarchies\n- **Substantive interpretation**: Understanding role meanings\n\n### Advanced Topics (Coming Soon)\n\n- Small-world analysis and metrics\n- Cohesive blocking and k-components\n- Dynamic community detection\n- Overlapping community detection\n\n:::\n\n\n## Perform\n\n\n::: {.callout-note}\n## üìù\n\n**Application exercises**:\n\n1. **Community Analysis**: Apply multiple community detection algorithms to a\n   network and compare results. Assess which method best captures substantive\ncommunities.\n\n2. **Role Structure Analysis**: Perform a blockmodeling analysis to identify\n   role positions in an organizational or social network. Create and interpret\nthe image matrix.\n\n3. **Integration**: Examine whether communities correspond to positions - do\n   structurally equivalent actors tend to be in the same community?\n\n:::\n\n## Ponder\n\n::: {.callout-note}\n## ü§î\n\n### Core Readings\n\n**Cohesion and Communities**\n\nChapter 8 (\"Cohesion and Groups\") from Borgatti, S. P., Everett, M. G.,\nJohnson, J. C., & Agneessens, F. (2024). *Analyzing Social Networks Using R*.\nSage Publications.\n\n**Foundational Work on Blockmodeling**\n\nWhite, H. C., Boorman, S. A., & Breiger, R. L. (1976). Social structure from\nmultiple networks. I. Blockmodels of roles and positions. *American Journal of\nSociology*, 81(4), 730-780.\n\n**Community Detection Algorithms**\n\nNewman, M. E. J., & Girvan, M. (2004). Finding and evaluating community\nstructure in networks. *Physical Review E*, 69(2), 026113.\n\nBlondel, V. D., Guillaume, J. L., Lambiotte, R., & Lefebvre, E. (2008). Fast\nunfolding of communities in large networks. *Journal of Statistical Mechanics:\nTheory and Experiment*, 2008(10), P10008.\n\n**Small-World Networks**\n\nWatts, D. J., & Strogatz, S. H. (1998). Collective dynamics of 'small-world'\nnetworks. *Nature*, 393(6684), 440-442.\n\nGranovetter, M. S. (1973). The strength of weak ties. *American Journal of\nSociology*, 78(6), 1360-1380.\n\n### Supplementary Readings\n\n**Structural Cohesion**\n\nMoody, J., & White, D. R. (2003). Structural cohesion and embeddedness: A\nhierarchical concept of social groups. *American Sociological Review*, 68(1),\n103-127.\n\n**Generalized Blockmodeling**\n\nDoreian, P., Batagelj, V., & Ferligoj, A. (2005). *Generalized Blockmodeling*.\nCambridge University Press.\n\n**Role Equivalence**\n\nBurt, R. S. (1990). Detecting role equivalence. *Social Networks*, 12(1),\n83-97.\n\n**Applications**\n\nPadgett, J. F., & Ansell, C. K. (1993). Robust action and the rise of the\nMedici, 1400-1434. *American Journal of Sociology*, 98(6), 1259-1319.\n\n### Conceptual Connections\n\n**Mechanical vs. Organic Solidarity**\n\nConsider how Durkheim's distinction between mechanical solidarity (based on\nsimilarity) and organic solidarity (based on differentiated interdependence)\nmaps onto the distinction between communities and role structures.\n\n**Methodological Pluralism**\n\nReflect on why there is no single \"best\" method for community detection or\nblockmodeling. What does this tell us about the nature of social structure?\n\n**Integration of Approaches**\n\nHow might communities and positions relate to each other? Can structurally\nequivalent actors be in different communities? Can community members occupy\ndifferent positions?\n\n:::\n\n\n## Quick Reference: Essential R Code\n\n### Community Detection Snippets\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(igraph)\n\n# Load network\ng <- make_graph(\"Zachary\")  # or read from file\n\n# Method 1: Louvain (fast, modularity-based)\ncomm_louvain <- cluster_louvain(g)\n\n# Method 2: Leiden (improved Louvain)\ncomm_leiden <- cluster_leiden(g)\n\n# Method 3: Walktrap (random walk-based)\ncomm_walktrap <- cluster_walktrap(g, steps = 4)\n\n# Method 4: Edge Betweenness (hierarchical)\ncomm_edgebet <- cluster_edge_betweenness(g)\n\n# Method 5: Fast Greedy (hierarchical modularity)\ncomm_fastgreedy <- cluster_fast_greedy(g)\n\n# Extract results\nmembership(comm_louvain)         # Community assignments\nlength(comm_louvain)             # Number of communities\nsizes(comm_louvain)              # Community sizes\nmodularity(comm_louvain)         # Modularity score\n\n# Compare methods\ncompare(comm_louvain, comm_leiden, method = \"nmi\")  # Agreement\n\n# Visualize\nplot(comm_louvain, g,\n     vertex.size = 8,\n     edge.color = \"gray80\",\n     main = \"Communities\")\n```\n:::\n\n\n### Blockmodeling Snippets\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(igraph)\n\ng <- sample_pa(20, directed = TRUE)\nadj <- as.matrix(as_adjacency_matrix(g))\n\n# Method 1: Correlation-based equivalence\nequiv_cor <- cor(t(adj))          # Correlate row profiles\ndist_cor <- as.dist(1 - equiv_cor)\nhc_cor <- hclust(dist_cor, method = \"complete\")\npositions_cor <- cutree(hc_cor, k = 4)\n\n# Method 2: Euclidean distance equivalence\ndist_euclidean <- dist(adj, method = \"euclidean\")\nhc_euclidean <- hclust(dist_euclidean, method = \"ward.D2\")\npositions_euclidean <- cutree(hc_euclidean, k = 4)\n\n# Visualize dendrogram\nplot(hc_cor, main = \"Position Hierarchy\", xlab = \"Node\")\nrect.hclust(hc_cor, k = 4, border = \"red\")\n\n# Create image matrix\nn_pos <- max(positions_cor)\nimage_matrix <- matrix(0, nrow = n_pos, ncol = n_pos)\n\nfor(i in 1:n_pos) {\n  for(j in 1:n_pos) {\n    block <- adj[positions_cor == i, positions_cor == j]\n    image_matrix[i, j] <- mean(block)\n  }\n}\n\nprint(round(image_matrix, 2))\n\n# Visualize with position colors\nV(g)$color <- rainbow(n_pos)[positions_cor]\nplot(g, vertex.size = 8, main = \"Network by Position\")\n```\n:::\n\n\n### Essential Network Data Sources\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(igraph)\n\n# Built-in networks\nkarate <- make_graph(\"Zachary\")              # Karate club\ndolphins <- make_graph(\"Dolphins\")            # Dolphin social network\n\n# Generate synthetic networks\nerdos_renyi <- sample_gnp(100, 0.05)         # Random\nbarabasi <- sample_pa(100, power = 1)        # Scale-free\nsmall_world <- watts.strogatz.game(1, 100, 5, 0.1)  # Small-world\n\n# Read from file\ng_edgelist <- read_graph(\"network.txt\", format = \"edgelist\")\ng_graphml <- read_graph(\"network.graphml\", format = \"graphml\")\ng_gml <- read_graph(\"network.gml\", format = \"gml\")\n\n# From adjacency matrix\nadj_matrix <- as.matrix(read.csv(\"adjacency.csv\", row.names = 1))\ng_adj <- graph_from_adjacency_matrix(adj_matrix, mode = \"undirected\")\n\n# From data frame\nedges_df <- data.frame(from = c(\"A\", \"B\", \"C\"),\n                       to = c(\"B\", \"C\", \"D\"))\ng_df <- graph_from_data_frame(edges_df, directed = TRUE)\n```\n:::\n\n\n## Additional Resources\n\n\n::: {.callout-tip}\n## üîß Software and Tools\n\n**R packages**:\n\n- `igraph`: Community detection, blockmodeling\n- `sna` and `network`: Role equivalence, structural cohesion\n- `blockmodeling`: Generalized blockmodeling\n\n**Python packages**:\n\n- `igraph`: Community detection algorithms\n- `networkx`: Modularity, community detection\n- `python-louvain`: Louvain algorithm implementation\n- `leidenalg`: Leiden algorithm\n\n**Visualization**:\n\n- Gephi: Interactive community visualization\n- Cytoscape: Network analysis and visualization\n- R packages: `ggraph`, `visNetwork`\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
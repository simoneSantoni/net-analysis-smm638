{
  "hash": "2cd6d5a5d6ec827c1115e6f0ffcf2916",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Practice Exercise: Graph Uniform Test\"\nsubtitle: \"Week 4 - Network Analytics\"\nformat:\n  html:\n    toc: true\n    code-fold: false\n---\n\n## Exercise Overview\n\nIn this exercise, we'll explore the **Graph Uniform Test** (also known as network permutation test) using the R package `sna`. We'll work with two toy networks:\n\n1. **Friendship Network** (undirected): Test for triadic closure\n2. **Following Network** (directed): Test for reciprocity\n\nThe uniform graph test helps us determine whether observed network properties differ significantly from what we would expect in random networks.\n\n## Setup\n\nFirst, let's load the required packages and set up our environment:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sna)\nlibrary(network)\nset.seed(123)  # for reproducibility\n```\n:::\n\n\n## Part 1: Friendship Network - Testing Triadic Closure\n\n### Creating the Friendship Network\n\nLet's create a small undirected friendship network:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create friendship adjacency matrix (undirected)\nfriendship_mat <- matrix(0, nrow = 8, ncol = 8)\nrownames(friendship_mat) <- colnames(friendship_mat) <- LETTERS[1:8]\n\n# Add friendships (symmetric for undirected)\n# A is friends with B, C, D\nfriendship_mat[\"A\", c(\"B\", \"C\", \"D\")] <- 1\nfriendship_mat[c(\"B\", \"C\", \"D\"), \"A\"] <- 1\n\n# B is friends with C, E\nfriendship_mat[\"B\", c(\"C\", \"E\")] <- 1\nfriendship_mat[c(\"C\", \"E\"), \"B\"] <- 1\n\n# C is friends with D, F\nfriendship_mat[\"C\", c(\"D\", \"F\")] <- 1\nfriendship_mat[c(\"D\", \"F\"), \"C\"] <- 1\n\n# D is friends with F, G\nfriendship_mat[\"D\", c(\"F\", \"G\")] <- 1\nfriendship_mat[c(\"F\", \"G\"), \"D\"] <- 1\n\n# E is friends with F\nfriendship_mat[\"E\", \"F\"] <- 1\nfriendship_mat[\"F\", \"E\"] <- 1\n\n# Create network object\nfriendship_net <- network(friendship_mat, directed = FALSE)\n```\n:::\n\n\n### Visualize the Friendship Network\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot the friendship network\ngplot(friendship_net, \n      vertex.col = \"#c41c85\",\n      vertex.cex = 2,\n      label = network.vertex.names(friendship_net),\n      label.col = \"white\",\n      label.cex = 0.8,\n      edge.col = \"#D3D3D3\",\n      edge.lwd = 2,\n      main = \"Friendship Network\",\n      mode = \"fruchtermanreingold\")\n```\n\n::: {.cell-output-display}\n![](practice_1_files/figure-html/unnamed-chunk-3-1.png){width=768}\n:::\n:::\n\n\n### Testing for Triadic Closure\n\nTriadic closure refers to the tendency for friends of friends to become friends. We'll use the transitivity coefficient as our test statistic:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate observed transitivity (clustering coefficient)\nobs_trans <- gtrans(friendship_net, mode = \"graph\")\ncat(\"Observed transitivity:\", round(obs_trans, 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nObserved transitivity: 0.4091 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Perform uniform graph test\n# We'll generate 1000 random networks with same size and density\nn_perms <- 1000\nrandom_trans <- numeric(n_perms)\n\n# Get network properties\nn_nodes <- network.size(friendship_net)\nn_edges <- network.edgecount(friendship_net)\n\nfor(i in 1:n_perms) {\n  # Generate random network with same number of nodes and edges\n  random_net <- rgraph(n_nodes, \n                       m = 1, \n                       tprob = n_edges/(n_nodes*(n_nodes-1)/2),\n                       mode = \"graph\")\n  random_trans[i] <- gtrans(random_net, mode = \"graph\")\n}\n\n# Calculate p-value\np_value <- mean(random_trans >= obs_trans)\ncat(\"\\nP-value for triadic closure test:\", round(p_value, 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nP-value for triadic closure test: 0.285 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Visualize results\nhist(random_trans, \n     breaks = 30,\n     main = \"Distribution of Transitivity in Random Networks\",\n     xlab = \"Transitivity\",\n     col = \"lightgray\",\n     xlim = c(0, max(c(obs_trans, random_trans)) * 1.1))\nabline(v = obs_trans, col = \"#c41c85\", lwd = 3)\ntext(obs_trans, par(\"usr\")[4] * 0.9, \"Observed\", col = \"#c41c85\", pos = 4)\n```\n\n::: {.cell-output-display}\n![](practice_1_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-tip}\n## Interpretation\nIf p-value < 0.05, we reject the null hypothesis that the network is random. This suggests significant triadic closure - friends of friends tend to become friends more than expected by chance.\n:::\n\n## Part 2: Following Network - Testing Reciprocity\n\n### Creating the Following Network\n\nNow let's create a directed network representing who follows whom:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create following adjacency matrix (directed)\nfollowing_mat <- matrix(0, nrow = 6, ncol = 6)\nrownames(following_mat) <- colnames(following_mat) <- c(\"Alice\", \"Bob\", \"Carol\", \"Dave\", \"Eve\", \"Frank\")\n\n# Add following relationships (asymmetric for directed)\n# Alice follows Bob and Carol\nfollowing_mat[\"Alice\", c(\"Bob\", \"Carol\")] <- 1\n\n# Bob follows Alice and Dave\nfollowing_mat[\"Bob\", c(\"Alice\", \"Dave\")] <- 1\n\n# Carol follows Alice, Bob, and Eve\nfollowing_mat[\"Carol\", c(\"Alice\", \"Bob\", \"Eve\")] <- 1\n\n# Dave follows Bob and Frank\nfollowing_mat[\"Dave\", c(\"Bob\", \"Frank\")] <- 1\n\n# Eve follows Carol and Frank\nfollowing_mat[\"Eve\", c(\"Carol\", \"Frank\")] <- 1\n\n# Frank follows Eve\nfollowing_mat[\"Frank\", \"Eve\"] <- 1\n\n# Create network object\nfollowing_net <- network(following_mat, directed = TRUE)\n```\n:::\n\n\n### Visualize the Following Network\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot the following network\ngplot(following_net, \n      vertex.col = \"#50C878\",\n      vertex.cex = 2,\n      label = network.vertex.names(following_net),\n      label.col = \"white\",\n      label.cex = 0.8,\n      edge.col = \"#D3D3D3\",\n      edge.lwd = 2,\n      edge.curve = 0.1,\n      arrowhead.cex = 0.8,\n      main = \"Following Network (Directed)\",\n      mode = \"kamadakawai\")\n```\n\n::: {.cell-output-display}\n![](practice_1_files/figure-html/unnamed-chunk-6-1.png){width=768}\n:::\n:::\n\n\n### Testing for Reciprocity\n\nReciprocity measures the tendency for directed ties to be mutual (if A follows B, does B follow A?):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate observed reciprocity\nobs_recip <- grecip(following_net, measure = \"edgewise\")\ncat(\"Observed reciprocity:\", round(obs_recip, 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nObserved reciprocity: 0.8333 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Perform uniform graph test\nrandom_recip <- numeric(n_perms)\n\n# Get network properties\nn_nodes_dir <- network.size(following_net)\nn_edges_dir <- network.edgecount(following_net)\n\nfor(i in 1:n_perms) {\n  # Generate random directed network with same number of nodes and edges\n  random_net_dir <- rgraph(n_nodes_dir, \n                           m = 1,\n                           tprob = n_edges_dir/(n_nodes_dir*(n_nodes_dir-1)),\n                           mode = \"digraph\")\n  random_recip[i] <- grecip(random_net_dir, measure = \"edgewise\")\n}\n\n# Calculate p-value\np_value_recip <- mean(random_recip >= obs_recip)\ncat(\"\\nP-value for reciprocity test:\", round(p_value_recip, 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nP-value for reciprocity test: 0.002 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Visualize results\nhist(random_recip, \n     breaks = 30,\n     main = \"Distribution of Reciprocity in Random Networks\",\n     xlab = \"Reciprocity\",\n     col = \"lightgray\",\n     xlim = c(0, max(c(obs_recip, random_recip)) * 1.1))\nabline(v = obs_recip, col = \"#50C878\", lwd = 3)\ntext(obs_recip, par(\"usr\")[4] * 0.9, \"Observed\", col = \"#50C878\", pos = 4)\n```\n\n::: {.cell-output-display}\n![](practice_1_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-tip}\n## Interpretation\nIf p-value < 0.05, we reject the null hypothesis. This indicates significant reciprocity - mutual following relationships occur more often than expected in random networks.\n:::\n\n## Your Turn\n\nTry these exercises to deepen your understanding:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exercise 1: Test degree centralization in the friendship network\n# Hint: Use centralization() function\n\n# Your code here\n\n\n# Exercise 2: Test for in-degree centralization in the following network\n# Hint: Use centralization() with appropriate parameters\n\n# Your code here\n\n\n# Exercise 3: Create your own network and test a different property\n# Ideas: betweenness centralization, diameter, or density differences\n\n# Your code here\n```\n:::\n\n\n## Key Takeaways\n\n1. **Graph Uniform Test** compares observed network statistics to distributions from random networks\n2. The choice of **null model** (how we generate random networks) is crucial\n3. **P-values** indicate whether observed patterns could arise by chance\n4. Common tests include:\n   - **Transitivity/Clustering**: Friend-of-friend connections\n   - **Reciprocity**: Mutual connections in directed networks\n   - **Centralization**: Concentration of connections\n   - **Assortativity**: Similar nodes connecting\n\n::: {.callout-note collapse=\"true\"}\n## Solutions to Exercises\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exercise 1 Solution: Test degree centralization in friendship network\nobs_cent <- centralization(friendship_net, degree, mode = \"graph\")\nrandom_cent <- numeric(n_perms)\n\nfor(i in 1:n_perms) {\n  random_net <- rgraph(n_nodes, m = 1, \n                       tprob = n_edges/(n_nodes*(n_nodes-1)/2),\n                       mode = \"graph\")\n  random_cent[i] <- centralization(random_net, degree, mode = \"graph\")\n}\n\np_value_cent <- mean(random_cent >= obs_cent)\ncat(\"Degree centralization p-value:\", round(p_value_cent, 4), \"\\n\")\n\n# Exercise 2 Solution: Test in-degree centralization in following network\nobs_cent_in <- centralization(following_net, degree, cmode = \"indegree\")\nrandom_cent_in <- numeric(n_perms)\n\nfor(i in 1:n_perms) {\n  random_net_dir <- rgraph(n_nodes_dir, m = 1,\n                           tprob = n_edges_dir/(n_nodes_dir*(n_nodes_dir-1)),\n                           mode = \"digraph\")\n  random_cent_in[i] <- centralization(random_net_dir, degree, cmode = \"indegree\")\n}\n\np_value_cent_in <- mean(random_cent_in >= obs_cent_in)\ncat(\"In-degree centralization p-value:\", round(p_value_cent_in, 4), \"\\n\")\n```\n:::\n\n:::",
    "supporting": [
      "practice_1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}